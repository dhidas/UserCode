//***********************************************************************
//***** src/OSUAnalysis/Tools/bin/sourceCodeReference.txt
//***** Contains all source code from src and interface directories
//***** Provides single file for source code searching
//*****
//***** Note:  Consider performing case-insensitive searches
//***** or do searches for both upper and lower case.
//***********************************************************************


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/ToplikeCandidate.cpp
//***********************************************************************


#include "../interface/ToplikeCandidate.h"
#include <iostream>
#include <iomanip>


using namespace std;
using namespace BAT;

namespace BAT {

static const int BQ_ID = 5, TOP_ID = 6, W_ID = 24, ELECTRON_ID = 11;
static const int NU_E_ID = 12;
static const unsigned int MCLIMIT = 12;  // Number of MC particles to check
static const float DELTA_R_LIMIT = 0.5; // Biggest deltaR to consider in range
static const double pt_tprime_sys_mean = 48.49;
static const double pt_tprime_sys_sigma = 27.87;

ToplikeCandidate::ToplikeCandidate() :
  jet3FromWIndex(0),
  jet4FromWIndex(0),
  doneReconstructiontop(false)
{
}
    
  
ToplikeCandidate::ToplikeCandidate(const Event& event) :
  TopPairEventCandidate(event),
  jet3FromWIndex(0),
  jet4FromWIndex(0),
  doneReconstructiontop(false)
{
}


ToplikeCandidate::~ToplikeCandidate()
{
}


const ParticlePointer ToplikeCandidate::getResonance() const {
    throwExpeptionIfNotReconstructed();
    return tPrime;
}


double ToplikeCandidate::tpmass() const {
    /*
    ParticlePointer tmp = ParticlePointer(new Particle(*leptonicTop1 + *hadronicW));
    cout << "tmp px = " << tmp->px() << " tp py = " << tmp->py() << " tp pz = " << tmp->pz() << endl;
    cout << "energy = " << tmp->energy() << endl;
    return tmp->mass();
    cout << "tp px = " << tPrime->px() << " tp py = " << tPrime->py() << " tp pz = " << tPrime->pz() << endl;
    cout << "energy = " << tPrime->energy() << endl;
    if (tPrime->px() <= 0)
      tPrime->setMass(0.0);
    */
    return tPrime->mass();
}


double ToplikeCandidate::sumPt() const {
    return (jet1FromW->pt() + jet2FromW->pt() + hadronicBJet->pt());
}


double ToplikeCandidate::getGlobalChi2() const {
    double pttbar = PtTtbarSystem();
    double pttbarTerm = TMath::Power(pttbar - pt_tprime_sys_mean, 2) / (2 *  pt_tprime_sys_sigma * pt_tprime_sys_sigma);

    double htSystemDifference = TMath::Power(HTSystem() - matched_HTSystem, 2);
    double htSystemError = matched_HTSystem_sigma * matched_HTSystem_sigma * 2;
    double htSystemTerm = htSystemDifference / htSystemError;
    return 1 / sqrt(2) * (pttbarTerm + htSystemTerm);
}


double ToplikeCandidate::PtTtbarSystem() const {
    ParticlePointer combined;
    combined = ParticlePointer(new Particle(*hadronicWtPrime + *hadronicTop));
    return combined->pt() / HTSystem();
}


double ToplikeCandidate::TPrimeHTSystem() const {
  return htSystem;
}


double ToplikeCandidate::PtTPrimeSystem() const {
  return ptTprimeSystem;
}


double ToplikeCandidate::PtTtbarSystem(unsigned short neutrinoSolution) const {
    ParticlePointer combined;
    if (neutrinoSolution == 1)
        combined = ParticlePointer(new Particle(*leptonicTop1 + *hadronicW));
    else
        combined = ParticlePointer(new Particle(*leptonicTop2 + *hadronicW));
    return combined->pt() / HTSystem();
}


double ToplikeCandidate::getWChi2() const {
  double WmassDifference = TMath::Power(hadronicWtPrime->mass() - matched_hadronic_W_mass, 2);
  double WmassError = 2 * matched_hadronic_W_mass_sigma * matched_hadronic_W_mass_sigma;
  double WmassTerm = WmassDifference / WmassError;
  return (1.0 / WmassTerm);
}


double ToplikeCandidate::getHadronicChi2() const {
    double WmassDifference = TMath::Power(hadronicW->mass() - matched_hadronic_W_mass, 2);
    double WmassError = 2 * matched_hadronic_W_mass_sigma * matched_hadronic_W_mass_sigma;
    double WmassTerm = WmassDifference / WmassError;

    return 1.0 / WmassTerm;
}


double ToplikeCandidate::getLoneHadChi2() const
{
  return (TopPairEventCandidate::getHadronicChi2());
}


/*
double ToplikeCandidate::getTotalChi2(unsigned short int neutrinoSolution) const {
    return getLeptonicChi2(neutrinoSolution) + getHadronicChi2() + getGlobalChi2(neutrinoSolution);
}
*/


void ToplikeCandidate::recoTprimeUsingChi2(ElectronPointer electron) {
  // cout << "Starting tp reco " << endl;
  if (goodJets.size() < 3)
    throw ReconstructionException("Not enough jets available to reconstruct Tprime using Chi2 method.");
  double chosen_Chi2Total(9999999.);
  electronFromW = electron;
  selectedNeutrino = 0;
  currentSelectedNeutrino = 0;
  reconstructNeutrinos();

  // cout << "Starting jet loop" << endl;
  for (unsigned short hadBindex = 0; hadBindex < goodJets.size(); ++hadBindex) {
    for (unsigned short jet1Index = 0; jet1Index < goodJets.size(); ++jet1Index) {
      if (jet1Index == hadBindex)
        continue;
      for (unsigned short jet2Index = 0; jet2Index < goodJets.size(); ++jet2Index) {
        if (jet2Index == jet1Index || jet2Index == hadBindex)
          continue;
        hadronicBJet = goodJets.at(hadBindex);
        leptonicBJet = hadronicBJet; // hack
        jet1FromW = goodJets.at(jet1Index);
        jet2FromW = goodJets.at(jet2Index);
        leptonicW1 = ParticlePointer(new Particle(*neutrino1 + *electronFromW));
        leptonicW2 = ParticlePointer(new Particle(*neutrino2 + *electronFromW));
        leptonicTop1 = ParticlePointer(new Particle(*hadronicBJet + *leptonicW1));
        leptonicTop2 = ParticlePointer(new Particle(*hadronicBJet + *leptonicW2));
        hadronicW = ParticlePointer(new Particle(*jet1FromW + *jet2FromW));
        // fillHypotheses();
        selectNeutrinoSolution();
        double chi2 = getTotalChi2(currentSelectedNeutrino);
        if (chi2 < chosen_Chi2Total) {
            hadronicBIndex = hadBindex;
            jet1FromWIndex = jet1Index;
            jet2FromWIndex = jet2Index;
            chosen_Chi2Total = chi2;
            selectedNeutrino = currentSelectedNeutrino;
        }
      }
    }
  }
  // cout << "Done with loop" << endl;
  hadronicBJet = goodJets.at(hadronicBIndex);
  leptonicBJet = hadronicBJet; // hack
  jet1FromW = goodJets.at(jet1FromWIndex);
  jet2FromW = goodJets.at(jet2FromWIndex);
  hadronicW = ParticlePointer(new Particle(*jet1FromW + *jet2FromW));
  leptonicW1 = ParticlePointer(new Particle(*neutrino1 + *electronFromW));
  leptonicW2 = ParticlePointer(new Particle(*neutrino2 + *electronFromW));
  leptonicTop1 = ParticlePointer(new Particle(*hadronicBJet + *leptonicW1));
  leptonicTop2 = ParticlePointer(new Particle(*hadronicBJet + *leptonicW2));
  ptTprimeSystem = PtTtbarSystem(selectedNeutrino);
  htSystem = HTSystem();
  if (selectedNeutrino == 1)
    tPrime = ParticlePointer(new Particle(*leptonicTop1 + *hadronicW));
  else 
    tPrime = ParticlePointer(new Particle(*leptonicTop2 + *hadronicW));
  // cout << "tPrime mass = " << tPrime->mass() << endl;
  doneReconstruction = true;
}


void ToplikeCandidate::recoBestSingleTop(ElectronPointer electron) {
  if (goodJets.size() < 3)
    throw ReconstructionException("Not enough jets available to reconstruct top using Chi2 method.");
  double bestLepChi2(9999999.), bestHadChi2(9999999.);
  electronFromW = electron;
  selectedNeutrino = 0;
  currentSelectedNeutrino = 0;
  reconstructNeutrinos();

  for (unsigned short hadBindex = 0; hadBindex < goodJets.size(); ++hadBindex) {
    for (unsigned short jet1Index = 0; jet1Index < goodJets.size(); ++jet1Index) {
        for (unsigned short jet2Index = 0; jet2Index < goodJets.size(); ++jet2Index) {
        if (jet2Index == jet1Index)
          continue;
        hadronicBJet = goodJets.at(hadBindex);
        leptonicBJet = hadronicBJet; // hack
        jet1FromW = goodJets.at(jet1Index);
        jet2FromW = goodJets.at(jet2Index);
        leptonicW1 = ParticlePointer(new Particle(*neutrino1 + *electronFromW));
        leptonicW2 = ParticlePointer(new Particle(*neutrino2 + *electronFromW));
        leptonicTop1 = ParticlePointer(new Particle(*hadronicBJet + *leptonicW1));
        leptonicTop2 = ParticlePointer(new Particle(*hadronicBJet + *leptonicW2));
        hadronicW = ParticlePointer(new Particle(*jet1FromW + *jet2FromW));
        hadronicTop = ParticlePointer(new Particle(*hadronicBJet + *hadronicW));
        // fillHypotheses();
        selectNeutrinoSolution();
        double ltopchi2 = getLeptonicChi2(currentSelectedNeutrino);
        double htopchi2 = getLoneHadChi2();
        if (ltopchi2 < bestLepChi2) {
          selectedNeutrino = currentSelectedNeutrino;
          leptonicBIndex = hadBindex;
          bestLepChi2 = ltopchi2;
        }
        if (htopchi2 < bestHadChi2) {
          hadronicBIndex = hadBindex;
          jet1FromWIndex = jet1Index;
          jet2FromWIndex = jet2Index;
          bestHadChi2 = htopchi2;
        }
      }
    }
  }
  hadronicBJet = goodJets.at(hadronicBIndex);
  leptonicBJet = goodJets.at(leptonicBIndex);
  jet1FromW = goodJets.at(jet1FromWIndex);
  jet2FromW = goodJets.at(jet2FromWIndex);
  hadronicW = ParticlePointer(new Particle(*jet1FromW + *jet2FromW));
  leptonicW1 = ParticlePointer(new Particle(*neutrino1 + *electronFromW));
  leptonicW2 = ParticlePointer(new Particle(*neutrino2 + *electronFromW));
  hadronicTop = ParticlePointer(new Particle(*hadronicBJet + *hadronicW));
  leptonicTop1 = ParticlePointer(new Particle(*leptonicBJet + *leptonicW1));
  leptonicTop2 = ParticlePointer(new Particle(*leptonicBJet + *leptonicW2));
  // cout << "Found lone tops " << endl;
  doneReconstructiontop = true;
  doneReconstruction = true;
}


static bool cmpMcEntries(const mcObj &firstArg, const mcObj &secondArg)
{
  return (firstArg.deltaR < secondArg.deltaR);
}


mcList ToplikeCandidate::getMCList(const Particle *const recoObject) const
{
  mcList mcObjs;
  const MCParticleCollection &mcColl = genParticles;
  if (mcColl.size() > 0) {
    for (unsigned int i = 0; i < mcColl.size(); ++i) {
      mcObj mcEntry;
      mcEntry.deltaR = recoObject->deltaR(mcColl.at(i));
      mcEntry.ptr = mcColl.at(i);
      mcEntry.gpInd = i;
      mcObjs.push_back(mcEntry);
    }
    sort(mcObjs.begin(), mcObjs.end(), cmpMcEntries);
  }
  return (mcObjs);
}
  

topTruth ToplikeCandidate::getMCMatches(const ParticlePointer &recoObject)
const
{
  const float nullDeltaR = 3;
  topTruth result = {nullDeltaR, false, false};
  mcList mcObjs = getMCList(recoObject.get());
  if (mcObjs.size() <= 0)
    return (result);
  /*
  if (mcObjs.begin()->first > 0.9)  // Nothing close enough
    return ("");
  TString idList;
  idList += mcObjs.at(0).first;
  idList += " ";
  for (unsigned int i = 0; i < mcObjs.size() && i < 12; ++i) {
    idList += PdgStrs::pdgStr(mcObjs.at(i).second);
    idList += " ";
  }
  */
  float topDeltaR = nullDeltaR;
  bool wFound = false, eFound = false;
  for (unsigned int i = 0; i < mcObjs.size() && i < MCLIMIT; ++i) {
    if (topDeltaR >= nullDeltaR && fabs(mcObjs.at(i).ptr->pdgId()) == TOP_ID)
      topDeltaR = mcObjs.at(i).deltaR;
    if (fabs(mcObjs.at(i).ptr->pdgId()) == ELECTRON_ID)
      eFound = true;
    if (fabs(mcObjs.at(i).ptr->pdgId()) == W_ID)
      wFound = true;
  }
  result.deltaR = topDeltaR;
  result.leptonic = wFound && eFound;
  result.hadronic = wFound;
  return (result);
}


static int findMCParticle(const mcList &mcObjs, int pdgId, int antiId = 0,
  unsigned int startInd = 0)
{
  if (antiId == 0)
    antiId = pdgId;
  for (unsigned int i = startInd; i < mcObjs.size(); ++i) {
    if (mcObjs.at(i).ptr->pdgId() == pdgId ||
        mcObjs.at(i).ptr->pdgId() == antiId) {
      if (mcObjs.at(i).deltaR < DELTA_R_LIMIT)
        return (i);
      else return (-1);
    }
  }
  return (-1);
}


int ToplikeCandidate::chkMCMatch(const Particle *const recoObject, 
  int motherInd, const int pdgId, int antiId) const
{
  mcList truList = getMCList(recoObject);
  if (truList.size() > 0) {
    int index = -1;
    while ((index = findMCParticle(truList, pdgId, antiId, index + 1)) >= 0)
      if (truList.at(index).ptr->motherIndex() == motherInd ||
          motherInd == -1)
        return (truList.at(index).gpInd);
  }
  return (-1);
}


// Look for a non-top quark whose mother is specified by motherInd and which
// doesn't match badInd.  If motherInd == -1, no mother is checked for.

int ToplikeCandidate::chkForQuark(const JetPointer recoObject, 
  const int motherInd, const int badInd) const
{
  mcList truList = getMCList(recoObject.get());
  if (truList.size() > 0) {
    for (int i = 0; i < (int) truList.size() &&
        truList.at(i).deltaR < DELTA_R_LIMIT; ++i) {
      if (truList.at(i).ptr->isQuark() && fabs(truList.at(i).ptr->pdgId()) !=
          TOP_ID && (truList.at(i).ptr->motherIndex() == motherInd ||
          motherInd == -1) && i != badInd)
        return (i);
        // Checking for q-qbar pair not necessary since both daughters of mother
    }
  }
  return (-1);
}


int ToplikeCandidate::strictHTopMatching(const mcObj &topTru) const
{
  int numFound = 1;   // Start with finding the top.
  short antiMult = 1;
  if (topTru.ptr->pdgId() < 0)
    antiMult = -1;
  if (chkMCMatch(hadronicBJet.get(), topTru.gpInd, BQ_ID * antiMult) >= 0)
    ++numFound;
  int wInd = chkMCMatch(hadronicW.get(), topTru.gpInd, W_ID * antiMult);
  if (wInd >= 0)
    ++numFound;
  else return (numFound);

  // Try to find 2 quarks from W.  If both fail, trying again will still fail
  // but is harmless.  If one fails, try again to see if can get both if we
  // let the other jet grab the 1st quark.  If that doesn't work, one quark
  // will still be found.
  int takenInd = chkForQuark(jet1FromW, wInd);
  if (takenInd >= 0 && chkForQuark(jet2FromW, wInd, takenInd) >= 0)
    numFound += 2;
  else {
    int takenInd = chkForQuark(jet2FromW, wInd);
    if (takenInd >= 0)
      ++numFound;
    if (chkForQuark(jet1FromW, wInd, takenInd))
      ++numFound;
  }
  return (numFound);
}


int ToplikeCandidate::strictLTopMatching(const mcObj &topTru) const
{
  int numFound = 1;
  short antiMult = 1;
  if (topTru.ptr->pdgId() < 0)
    antiMult = -1;
  if (chkMCMatch(getLeptonicBJet().get(), topTru.gpInd, BQ_ID * antiMult) >= 0)
    ++numFound;
  int wInd = chkMCMatch(getLeptonicW().get(), topTru.gpInd, W_ID * antiMult);
  if (wInd >= 0)
    ++numFound;
  else return (numFound);
  // Electron is opposite from top to preserve lepton number.
  if (chkMCMatch(getElectronFromWDecay().get(), wInd, -ELECTRON_ID * antiMult)
      >= 0)
    ++numFound;
  if (chkMCMatch(getNeutrinoFromWDecay().get(), wInd, NU_E_ID * antiMult) >= 0)
    ++numFound;
  return (numFound);
}


int ToplikeCandidate::getNumMCMatchesForTop(const ParticlePointer &recoTop, 
  bool hadronic)
  const
{
  mcList topTru = getMCList(recoTop.get());
  if (topTru.size() <= 0)
    return (0);
  int highestNumFound = 0;
  int topInd = -1;
  while ((topInd = findMCParticle(topTru, TOP_ID, -TOP_ID, topInd + 1)) >= 0) {
    int numFound = 0;
    if (hadronic)
       numFound = strictHTopMatching(topTru.at(topInd));
    else numFound = strictLTopMatching(topTru.at(topInd));
    if (numFound > highestNumFound)
      highestNumFound = numFound;
  }
  return (highestNumFound);
}


int ToplikeCandidate::getNumMCMatchesHTop() const
{
  return (getNumMCMatchesForTop(getHadronicTop(), true));
}


int ToplikeCandidate::getNumCorrectIDHTop() const
{
  mcList topTru = getMCList(getHadronicTop().get());
  int numFound = 0;
  if (topTru.size() > 0 && findMCParticle(topTru, TOP_ID, -TOP_ID) >= 0)
    ++numFound;
  
  // Take either particle or anti-particle.
  if (chkMCMatch(hadronicBJet.get(), -1, BQ_ID, -BQ_ID) >= 0)
    ++numFound;
  int wInd = chkMCMatch(hadronicW.get(), -1, W_ID, -W_ID);
  if (wInd >= 0)
    ++numFound;

  // Look for any quark near a jet.  Even allow the same quark for both jets.
  if (chkForQuark(jet1FromW, -1) >= 0)
      ++numFound;
  if (chkForQuark(jet2FromW, -1) >= 0)
      ++numFound;
  return (numFound);
}


int ToplikeCandidate::getNumMCMatchesLTop() const
{
  return (getNumMCMatchesForTop(getLeptonicTop(), false));
}


int ToplikeCandidate::getNumCorrectIDLTop() const
{
  mcList topTru = getMCList(getLeptonicTop().get());
  int numFound = 0;
  if (topTru.size() > 0 && findMCParticle(topTru, TOP_ID, -TOP_ID) >= 0)
    ++numFound;
  if (chkMCMatch(getLeptonicBJet().get(), -1, BQ_ID, -BQ_ID) >= 0)
    ++numFound;
  if (chkMCMatch(getLeptonicW().get(), -1, W_ID, -W_ID) >= 0)
    ++numFound;
  if (chkMCMatch(getElectronFromWDecay().get(), -1, -ELECTRON_ID,
      ELECTRON_ID) >= 0)
    ++numFound;
  if (chkMCMatch(getNeutrinoFromWDecay().get(), -1, NU_E_ID, -NU_E_ID) >= 0)
    ++numFound;
  return (numFound);
}


TopNoMassConstraint::TopNoMassConstraint()
{
}
    
  
TopNoMassConstraint::TopNoMassConstraint(const Event& event) :
  ToplikeCandidate(event)
{
}


TopNoMassConstraint::~TopNoMassConstraint()
{
}


// Omit top mass from criteria.
double TopNoMassConstraint::getLeptonicChi2(double unused, double angle)
  const
{
    double angleDifference = TMath::Power(angle - matched_angle, 2);
    double angleError = 2 * matched_angle_sigma * matched_angle_sigma;
    double angleTerm = angleDifference / angleError;
    return (1.0 / angleTerm);
}


double TopNoMassConstraint::getLoneHadChi2() const
{
    double ptRatioDifference = TMath::Power(PtRatio() - matched_ptratio, 2);
    double ptRatioError = 2 * matched_ptratio_sigma * matched_ptratio_sigma;
    double ptRatioTerm = ptRatioDifference / ptRatioError;

    double WmassDifference = TMath::Power(hadronicW->mass() - matched_hadronic_W_mass, 2);
    double WmassError = 2 * matched_hadronic_W_mass_sigma * matched_hadronic_W_mass_sigma;
    double WmassTerm = WmassDifference / WmassError;
    return 1.0 / sqrt(2.0) * (WmassTerm + ptRatioTerm);
}


}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/Printers/EventContentPrinter.cpp
//***********************************************************************


/*
 * EventPrinter.cpp
 *
 *  Created on: 22 Aug 2010
 *      Author: kreczko
 */

#include "../../interface/Printers/EventContentPrinter.h"
#include <iostream>
#include <iomanip>
using namespace std;

namespace BAT {
namespace EventContentPrinter {

extern void printJets(const JetCollection jets) {
    for (unsigned short index = 0; index < jets.size(); ++index) {
        const JetPointer jet = jets.at(index);
        cout << "Jet " << index + 1 << endl;
        printJet(jet);
    }
}

extern void printJet(const JetPointer jet) {
    printParticle(jet);
    cout << setw(30) << "emf" << setw(30) << "n90Hits" << setw(30) << "fHPD" << setw(30) << "B tag(SSV)" << endl;
    cout << setw(30) << jet->emf() << setw(30) << jet->n90Hits() << setw(30) << jet->fHPD() << setw(30)
            << jet->isBJet(BtagAlgorithm::SimpleSecondaryVertexHighEffBTag) << endl << endl;
    if(jet->getUsedAlgorithm() == JetAlgorithm::ParticleFlow || jet->getUsedAlgorithm() == JetAlgorithm::PF2PAT){
        printPFJetExtra(jet);
    }
}

extern void printPFJetExtra(const JetPointer jet){
    cout << setw(30) << "NOD" << setw(30) << "CEF" << setw(30) << "NHF" << setw(30) << "NEF" << endl;
    cout << setw(30) << jet->NOD() << setw(30) << jet->CEF() << setw(30) << jet->NHF() << setw(30)
                << jet->NEF() << endl << endl;

    cout << setw(30) << "CHF" << setw(30) << "NCH" << setw(30) << "" << setw(30) << "" << endl;
        cout << setw(30) << jet->CHF() << setw(30) << jet->NCH() << setw(30) << "" << setw(30)
                    << "" << endl << endl;
}

extern void printElectrons(const ElectronCollection electrons) {
    for (unsigned short index = 0; index < electrons.size(); ++index) {
        const ElectronPointer electron = electrons.at(index);
        cout << "Electron " << index + 1 << endl;
        printElectron(electron);
    }
}

extern void printElectron(const ElectronPointer electron) {
    printParticle(electron);
    cout << setw(30) << "VBTF70" << setw(30) << "VBTF95" << setw(30) << "robust loose" << setw(30) << "robust tight"
            << endl;
    cout << setw(30) << electron->VBTF_W70_ElectronID() << setw(30) << electron->VBTF_W95_ElectronID() << setw(30)
            << electron->RobustLooseID() << setw(30) << electron->RobustTightID() << endl;

    cout << setw(30) << "sigma_{ieta ieta}" << setw(30) << "|Delta phi_{in}|" << setw(30) << "|Delta eta_{in}|"
            << setw(30) << "HadOverEm" << endl;
    cout << setw(30) << electron->sigmaIEtaIEta() << setw(30) << fabs(electron->dPhiIn()) << setw(30) << fabs(
            electron->dEtaIn()) << setw(30) << electron->HadOverEm() << endl;

    cout << setw(30) << "isLoose" << setw(30) << "rel. iso." << setw(30) << "isFromConversion" << setw(30)
            << "superClusterEta" << endl;

    cout << setw(30) << electron->isLoose() << setw(30) << electron->relativeIsolation() << setw(30)
            << electron->isFromConversion() << setw(30) << electron->superClusterEta() << endl;

    //    cout << setw(30) << "isTrackerDriven" << setw(30) << "swiss_cross" << setw(30) << "isLoose" << setw(30)
    //            << "isEcalDriven" << endl;
}

extern void printParticle(const ParticlePointer particle) {
    cout << setw(30) << "pt" << setw(30) << "px" << setw(30) << "py" << setw(30) << "pz" << endl;
    cout << setw(30) << particle->pt() << setw(30) << particle->px() << setw(30) << particle->py() << setw(30)
            << particle->pz() << endl;

    cout << setw(30) << "energy" << setw(30) << "et" << setw(30) << "eta" << setw(30) << "phi" << endl;
    cout << setw(30) << particle->energy() << setw(30) << particle->et() << setw(30) << particle->eta() << setw(30)
            << particle->phi() << endl;

    cout << setw(30) << "d0" << setw(30) << "dyn. mass" << setw(30) << "fix. mass" << setw(30) << "charge" << endl;
    cout << setw(30) << particle->d0() << setw(30) << particle->massFromEnergyAndMomentum() << setw(30)
            << particle->mass() << setw(30) << particle->charge() << endl;
}

extern void printGenParticle(const MCParticlePointer genParticle) {
  printParticle(genParticle);

    cout << setw(30) << "pdgid" << setw(30) << "status" << setw(30) << "mother index" << setw(30) << "energy" << endl;
    cout << setw(30) << genParticle->pdgId() << setw(30) << genParticle->status() << setw(30) << genParticle->motherIndex() << setw(30)
            << genParticle->energy()<< endl;
}

}
}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/Printers/EventTablePrinter.cpp
//***********************************************************************


#include "../../interface/Printers/EventTablePrinter.h"
#include <iostream>
#include <iomanip>
#include "../../interface/TopPairEventCandidate.h"

namespace BAT {
namespace EventTablePrinter {
extern void printCutFlowLatexTable(const Counter& cutFlow) {
    using namespace std;
    cout << "Printing cut flow table" << endl;

    //print header
    cout << "\\newpage\n" << endl;
    cout << "\n%------------------------------------------------------------------------\n";
    cout << "%       " << "cut flow table (weighted)";
    cout << "\n%------------------------------------------------------------------------\n";
    cout << "\\begin{tabular}{|l|rrrrrr|r|}" << endl;
    cout << "\\hline" << endl;
    cout << "\\multicolumn{8}{|l|}";
    cout << "{Expected number of events for " << "36.145" << "/pb}";
    cout << "\\\\\\hline" << endl;
    cout << " Cut " << setw(40) << left << right;
    //    cout << "Cut" << setw(40);

    for (unsigned int type = 0; type < cutFlow.getSizeOfFirstDimension(); ++type) {
        if (type == DataType::QCD_BCtoE_Pt20to30) {//first QCD data type, this needs to be changed
            cout << " &" << setw(13) << "QCD";
        }
        if (type == DataType::singleTop_And_W)
            cout << " &" << setw(13) << "singeTop";

        if (type >= DataType::singleTop_And_W && type <= DataType::singleTopSChannel)
            continue;

        if (type >= DataType::QCD_BCtoE_Pt20to30 && type <= DataType::PhotonJets_Pt200toInf)
            continue;
        if (type == DataType::VQQ || type >= DataType::Zprime_M500GeV_W5GeV)//don't use them now
            continue;
        cout << " &" << setw(13) << DataType::names.at(type);
    }
    cout << " &" << setw(25) << "Total MC \\\\\n\\hline" << endl;
    for (unsigned int cut = 0; cut < cutFlow.getSizeOfSecondDimension(); ++cut) {
        unsigned long nQCD = 0;
        unsigned long nSingleTop = 0;
        unsigned long nTotalMC = 0;
        for (unsigned int type = 0; type < cutFlow.getSizeOfFirstDimension(); ++type) {
            if (type == 0) {
                cout << " Stage " << setw(2) << cut << " " << setw(40) << left
                        << TTbarEPlusJetsSelection::StringSteps[cut] << right;
            }
            if (type >= DataType::QCD_BCtoE_Pt20to30 && type <= DataType::PhotonJets_Pt200toInf)
                nQCD += cutFlow.sumThirdDimension(type, cut);

            if (type >= DataType::singleTop_And_W && type <= DataType::singleTopSChannel)
                nSingleTop += cutFlow.sumThirdDimension(type, cut);

            if (type == DataType::PhotonJets_Pt200toInf)
                cout << " & " << setw(12) << fixed << nQCD;

            if (type == DataType::singleTopSChannel)
                cout << " & " << setw(12) << fixed << nSingleTop;

            if (type > DataType::DATA)
                nTotalMC += cutFlow.sumThirdDimension(type, cut);

            if (type >= DataType::singleTop_And_W && type <= DataType::singleTopSChannel)
                continue;
            if (type >= DataType::QCD_BCtoE_Pt20to30 && type <= DataType::PhotonJets_Pt200toInf)
                continue;
            if (type == DataType::VQQ || type >= DataType::Zprime_M500GeV_W5GeV)//don't use them now
                continue;

            cout << " & " << setw(12) << fixed << cutFlow.sumThirdDimension(type, cut);
        }
        cout << " & " << setw(12) << fixed << nTotalMC;
        cout << "  \\\\\n\\hline" << endl;
    }

    cout << "\\end{tabular}\\\\[5mm]" << endl;
    cout << endl;
}
extern void printUnweightedCutFlowLatexTable(const Counter& cutFlow) {
    using namespace std;
    cout << "Printing cut flow table" << endl;

    //print header
    cout << "\\newpage\n" << endl;
    cout << "\n%------------------------------------------------------------------------\n";
    cout << "%       " << "cut flow table (unweighted)";
    cout << "\n%------------------------------------------------------------------------\n";
    cout << "\\begin{tabular}{|l|rrrrrrr|r|}" << endl;
    cout << "\\hline" << endl;
    cout << "\\multicolumn{8}{|l|}";
    cout << "{Expected number of events for " << "36.145" << "/pb}";
    cout << "\\\\\\hline" << endl;
    cout << " Cut " << setw(40) << left << right;
    //    cout << "Cut" << setw(40);

    for (unsigned int type = 0; type < cutFlow.getSizeOfFirstDimension(); ++type) {
        if (type == DataType::QCD_BCtoE_Pt20to30) {//first QCD data type, this needs to be changed
            cout << " &" << setw(13) << "QCD";
        }
        if (type == DataType::singleTop_And_W)
            cout << " &" << setw(13) << "singeTop";

        if (type >= DataType::singleTop_And_W && type <= DataType::singleTopSChannel)
            continue;

        if (type >= DataType::QCD_BCtoE_Pt20to30 && type <= DataType::PhotonJets_Pt200toInf)
            continue;
        if (type == DataType::VQQ || type >= DataType::Zprime_M500GeV_W5GeV)//don't use them now
            continue;
        cout << " &" << setw(13) << DataType::names.at(type);
    }
    cout << " &" << setw(25) << "Total MC \\\\\n\\hline" << endl;
    for (unsigned int cut = 0; cut < cutFlow.getSizeOfSecondDimension(); ++cut) {
        unsigned long nQCD = 0;
        unsigned long nSingleTop = 0;
        unsigned long nTotalMC = 0;
        for (unsigned int type = 0; type < cutFlow.getSizeOfFirstDimension(); ++type) {
            if (type == 0) {
                cout << " Stage " << setw(2) << cut << " " << setw(40) << left
                        << TTbarEPlusJetsSelection::StringSteps[cut] << right;
            }
            if (type >= DataType::QCD_BCtoE_Pt20to30 && type <= DataType::PhotonJets_Pt200toInf)
                nQCD += cutFlow.sumThirdDimensionUnweighted(type, cut);

            if (type >= DataType::singleTop_And_W && type <= DataType::singleTopSChannel)
                nSingleTop += cutFlow.sumThirdDimensionUnweighted(type, cut);

            if (type == DataType::PhotonJets_Pt200toInf)
                cout << " & " << setw(12) << fixed << nQCD;

            if (type == DataType::singleTopSChannel)
                cout << " & " << setw(12) << fixed << nSingleTop;

            if (type > DataType::DATA)
                nTotalMC += cutFlow.sumThirdDimensionUnweighted(type, cut);

            if (type >= DataType::singleTop_And_W && type <= DataType::singleTopSChannel)
                continue;
            if (type >= DataType::QCD_BCtoE_Pt20to30 && type <= DataType::PhotonJets_Pt200toInf)
                continue;
            if (type == DataType::VQQ || type >= DataType::Zprime_M500GeV_W5GeV)//don't use them now
                continue;

            cout << " & " << setw(12) << fixed << cutFlow.sumThirdDimensionUnweighted(type, cut);
        }
        cout << " & " << setw(12) << fixed << nTotalMC;
        cout << "  \\\\\n\\hline" << endl;
    }

    cout << "\\end{tabular}\\\\[5mm]" << endl;
    cout << endl;
}

}
}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/Event.cpp
//***********************************************************************


/*
 * Event.cpp
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#include "../interface/Event.h"
#include <iostream>
using namespace std;

namespace BAT {
bool Event::useCustomConversionTagger = false;
bool Event::usePFIsolation = false;
Event::Event() :
    HLTs(new std::vector<int>()),
    vertices(),
    tracks(),
    allElectrons(),
    goodElectrons(),
    goodIsolatedElectrons(),
    goodPFIsolatedElectrons(),
    looseElectrons(),
    qcdElectrons(),
    allJets(),
    goodJets(),
    goodBJets(),
    allMuons(),
    goodMuons(),
    goodIsolatedMuons(),
    genParticles(),
    met(),
    dataType(DataType::DATA),
    runNumber(0),
    eventNumber(0),
    lumiBlock(0),
    eventWeight(1.),
    jetCleaningEfficiency(1.),
    numberOfHighPurityTracks(0),
    isBeamScraping(true){
}

Event::~Event() {
}

bool Event::isRealData() const {
    return dataType == DataType::DATA;
}

const DataType::value Event::getDataType() const {
    return dataType;
}

void Event::setDataType(DataType::value type) {
    dataType = type;
}

void Event::setVertices(VertexCollection vertices) {
    this->vertices = vertices;
}

void Event::setTracks(TrackCollection tracks) {
    this->tracks = tracks;
    numberOfHighPurityTracks = 0;
    for (unsigned int index = 0; index < tracks.size(); ++index) {
        if (tracks.at(index)->isHighPurity())
            numberOfHighPurityTracks++;
    }
}

void Event::setGenParticles(MCParticleCollection genParticles) {
  this->genParticles = genParticles;
}

void Event::setElectrons(ElectronCollection electrons) {
    allElectrons.clear();
    allElectrons = electrons;
    selectElectronsByQuality();
}

void Event::selectElectronsByQuality() {
    goodElectrons.clear();
    goodIsolatedElectrons.clear();
    goodPFIsolatedElectrons.clear();
    for (unsigned int index = 0; index < allElectrons.size(); ++index) {
        ElectronPointer electron = allElectrons.at(index);

        if (electron->isGood())
            goodElectrons.push_back(electron);

        if(electron->isGood(20))
            qcdElectrons.push_back(electron);

        if (electron->isGood() && electron->isIsolated())
            goodIsolatedElectrons.push_back(electron);

        if(electron->algorithm() == ElectronAlgorithm::ParticleFlow){
            if(electron->isGood() && electron->isPFIsolated())
                goodPFIsolatedElectrons.push_back(electron);
        }

        if (electron->isGood() == false && electron->isLoose())
            looseElectrons.push_back(electron);
    }
}

void Event::setJets(JetCollection jets) {
    allJets.clear();
    allJets = jets;
    selectGoodJets();
}

void Event::setGenJets(JetCollection jets) {
    genJets.clear();
    genJets = jets;
}


void Event::selectGoodJets() {
    goodJets.clear();
    for (unsigned int index = 0; index < allJets.size(); ++index) {
        const JetPointer jet = allJets.at(index);
        if (jet->isGood()) {
            goodJets.push_back(jet);
        }
    }
    cleanGoodJets();
    for (unsigned int index = 0; index < goodJets.size(); ++index) {
        const JetPointer jet = goodJets.at(index);
        if (jet->isBJet(BtagAlgorithm::SimpleSecondaryVertexHighEffBTag))
            goodBJets.push_back(jet);
    }
}

void Event::cleanGoodJets() {
    if (goodIsolatedElectrons.size() > 0 && goodJets.size() > 0)
        cleanGoodJetsAgainstIsolatedElectrons();
    else if (allElectrons.size() > 0 && goodJets.size() > 0)
        cleanGoodJetsAgainstMostIsolatedElectron();
}

void Event::cleanGoodJetsAgainstIsolatedElectrons() {
    unsigned int initialGoodJets = goodJets.size();
    for (unsigned int jetIndex = 0; jetIndex < goodJets.size(); ++jetIndex) {
        for (unsigned int electronIndex = 0; electronIndex < goodIsolatedElectrons.size(); ++electronIndex) {
            if (goodJets.at(jetIndex)->isWithinDeltaR(0.3, goodIsolatedElectrons.at(electronIndex))) {
                goodJets.erase(goodJets.begin() + jetIndex);
                --jetIndex;
                break;
            }
        }
    }
    jetCleaningEfficiency = goodJets.size() / initialGoodJets;
}

void Event::cleanGoodJetsAgainstMostIsolatedElectron() {
    const ElectronPointer mostIsolatedElectron = MostIsolatedElectron(Event::usePFIsolation);
    unsigned int initialGoodJets = goodJets.size();
    for (unsigned int jetIndex = 0; jetIndex < goodJets.size(); ++jetIndex) {
        if (goodJets.at(jetIndex)->isWithinDeltaR(0.3, mostIsolatedElectron)) {
            goodJets.erase(goodJets.begin() + jetIndex);
            --jetIndex;
        }
    }
    jetCleaningEfficiency = goodJets.size() / initialGoodJets;
}

const ElectronPointer Event::MostIsolatedElectron(bool usePFIso) const {
    float bestIsolation = 999999999;
    unsigned int bestIsolatedElectron = 990;
    for (unsigned int index = 0; index < allElectrons.size(); ++index) {
        float currentIsolation = 999999999;
        if(usePFIso)
            currentIsolation = allElectrons.at(index)->pfIsolation();
        else
            currentIsolation = allElectrons.at(index)->relativeIsolation();

        if (currentIsolation < bestIsolation) {
            bestIsolation = currentIsolation;
            bestIsolatedElectron = index;
        }
    }
    return allElectrons.at(bestIsolatedElectron);
}

const ElectronPointer Event::MostIsolatedElectron() const{
    return MostIsolatedElectron(false);
}

const ElectronPointer Event::MostPFIsolatedElectron() const{
    return MostIsolatedElectron(true);
}


void Event::setMuons(MuonCollection muons) {
    allMuons.clear();
    allMuons = muons;
    selectMuonsByQuality();
}

void Event::selectMuonsByQuality() {
    goodMuons.clear();
    goodIsolatedMuons.clear();
    for (unsigned int index = 0; index < allMuons.size(); ++index) {
        MuonPointer muon = allMuons.at(index);

        if (muon->isGood())
            goodMuons.push_back(muon);

        if (muon->isGood() && muon->isIsolated())
            goodIsolatedMuons.push_back(muon);
    }
}

void Event::setHLTs(const boost::shared_ptr<std::vector<int> > triggers){
    HLTs = triggers;
}

void Event::setMET(const METPointer met) {
    this->met = met;
}

void Event::setRunNumber(unsigned long number) {
    runNumber = number;
}

void Event::setEventNumber(unsigned long number) {
    eventNumber = number;
}

void Event::setLocalEventNumber(unsigned long number) {
    localEventNumber = number;
}

void Event::setLumiBlock(unsigned long block) {
    lumiBlock = block;
}

void Event::setEventWeight(float weight) {
    eventWeight = weight;
}

void Event::setBeamScrapingVeto(bool isScraping){
    isBeamScraping = isScraping;
}

const VertexPointer Event::PrimaryVertex() const {
    return vertices.front();
}

const VertexCollection& Event::Vertices() const {
    return vertices;
}

const TrackCollection& Event::Tracks() const {
    return tracks;
}

const ElectronCollection& Event::Electrons() const {
    return allElectrons;
}

const ElectronCollection& Event::GoodElectrons() const {
    return goodElectrons;
}

const ElectronCollection& Event::GoodIsolatedElectrons() const {
    return goodIsolatedElectrons;
}

const ElectronCollection& Event::GoodPFIsolatedElectrons() const {
    return goodPFIsolatedElectrons;
}

const ElectronCollection& Event::QCDElectrons() const{
    return qcdElectrons;
}

const JetCollection& Event::Jets() const {
    return allJets;
}

const JetCollection& Event::GenJets() const {
    return genJets;
}


const JetCollection& Event::GoodJets() const {
    return goodJets;
}

const JetCollection& Event::GoodBJets() const {
    return goodBJets;
}

const MuonCollection& Event::Muons() const {
    return allMuons;
}

const MuonCollection& Event::GoodMuons() const {
    return goodMuons;
}

const MuonCollection& Event::GoodIsolatedMuons() const {
    return goodIsolatedMuons;
}

const MCParticleCollection& Event::GenParticles() const {
  return genParticles;
}

const METPointer Event::MET() const {
    return met;
}

unsigned long Event::runnumber() const {
    return runNumber;
}

unsigned long Event::eventnumber() const {
    return eventNumber;
}

unsigned long Event::localnumber() const {
    return localEventNumber;
}

unsigned long Event::lumiblock() const {
    return lumiBlock;
}

float Event::weight() const {
    return eventWeight;
}

void Event::inspect() const {
    cout << "run " << runNumber << ", event number " << eventNumber << ", lumi section " << lumiBlock << endl;

    cout << "number of tracks: " << tracks.size() << endl;
    cout << "number of high purity tracks: " << numberOfHighPurityTracks << endl;

    cout << "number of jets: " << allJets.size() << endl;
    EventContentPrinter::printJets(allJets);
    cout << "number of good jets: " << goodJets.size() << endl;
    EventContentPrinter::printJets(goodJets);

    cout << "number of good isolated electrons: " << goodIsolatedElectrons.size() << endl;
    EventContentPrinter::printElectrons(goodIsolatedElectrons);

    cout << "number of good electrons: " << goodElectrons.size() << endl;
    EventContentPrinter::printElectrons(goodElectrons);

    cout << "number of electrons: " << allElectrons.size() << endl;
    EventContentPrinter::printElectrons(allElectrons);
}

bool Event::HLT(HLTriggers::value trigger) const{
    return HLTs->at(trigger) > 0;
}

}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/OnlyForTests/DummyTTbarEvent.cpp
//***********************************************************************


/*
 * DummyTTbarEvent.cpp
 *
 *  Created on: 25 Aug 2010
 *      Author: kreczko
 */

#include "../../interface/OnlyForTests/DummyTTbarEvent.h"
#include <iostream>

using namespace std;
namespace BAT {

DummyTTbarEvent::DummyTTbarEvent() :
    BAT::TopPairEventCandidate(), 
    passScraping(false), 
    passHLT(false), 
    passPV(false),
    passElectronCut(false),
    passConversion(false), 
    passConversionPartnerTrack(false), 
    passesMuon(false), 
    passes1JetCut(false),
    passes2JetCut(false),
    passes3JetCut(false),
    passes4JetCut(false),
    passesZveto(false), 
    useCustomReturnValues(false) {

}

DummyTTbarEvent::~DummyTTbarEvent() {
}

void DummyTTbarEvent::setElectronFromW(ElectronPointer electron) {
    electronFromW = electron;
}

bool DummyTTbarEvent::passesScrapingFilter() const {
    if (useCustomReturnValues)
        return passScraping;
    else
        return TopPairEventCandidate::passesScrapingFilter();
}

bool DummyTTbarEvent::passesHighLevelTrigger() const {
    if (useCustomReturnValues)
        return passHLT;
    else
        return TopPairEventCandidate::passesHighLevelTrigger();
}

bool DummyTTbarEvent::hasOneGoodPrimaryVertex() const {
    if (useCustomReturnValues)
        return passPV;
    else
        return TopPairEventCandidate::hasOneGoodPrimaryVertex();
}

bool DummyTTbarEvent::hasOnlyOneGoodIsolatedElectron() const {
    if (useCustomReturnValues)
        return passElectronCut;
    else
        return TopPairEventCandidate::hasOnlyOneGoodIsolatedElectron();
}

bool DummyTTbarEvent::isolatedElectronDoesNotComeFromConversion() const {
    if (useCustomReturnValues)
        return passConversion;
    else
        return TopPairEventCandidate::isolatedElectronDoesNotComeFromConversion();
}

bool DummyTTbarEvent::isolatedElectronNotTaggedAsFromConversion() const {
    if (useCustomReturnValues)
        return passConversionPartnerTrack;
    else
        return TopPairEventCandidate::isolatedElectronNotTaggedAsFromConversion();
}

bool DummyTTbarEvent::hasNoIsolatedMuon() const {
    if (useCustomReturnValues)
        return passesMuon;
    else
        return TopPairEventCandidate::hasNoIsolatedMuon();
}
bool DummyTTbarEvent::hasAtLeastOneGoodJet() const {
    if (useCustomReturnValues)
        return passes1JetCut;
    else
        return TopPairEventCandidate::hasAtLeastOneGoodJet();
}

bool DummyTTbarEvent::hasAtLeastTwoGoodJets() const {
    if (useCustomReturnValues)
        return passes2JetCut;
    else
        return TopPairEventCandidate::hasAtLeastTwoGoodJets();
}

bool DummyTTbarEvent::hasAtLeastThreeGoodJets() const {
    if (useCustomReturnValues)
        return passes3JetCut;
    else
        return TopPairEventCandidate::hasAtLeastThreeGoodJets();
}

bool DummyTTbarEvent::hasAtLeastFourGoodJets() const {
    if (useCustomReturnValues)
        return passes4JetCut;
    else
        return TopPairEventCandidate::hasAtLeastFourGoodJets();
}

bool DummyTTbarEvent::isNotAZBosonEvent() const {
    if (useCustomReturnValues)
        return passesZveto;
    else
        return TopPairEventCandidate::isNotAZBosonEvent();
}

bool DummyTTbarEvent::passesNMinus1(enum TTbarEPlusJetsSelection::Step omitted) const {
    bool passes(true);

    for (unsigned int cut = 0; cut < TTbarEPlusJetsSelection::NUMBER_OF_SELECTION_STEPS; ++cut) {
        if (cut == (unsigned int) omitted)
            continue;
        passes = passes && passesSelectionStep((TTbarEPlusJetsSelection::Step) cut);
    }
    return passes;
}

bool DummyTTbarEvent::passesSelectionStep(enum TTbarEPlusJetsSelection::Step step) const {
    switch (step) {
        case TTbarEPlusJetsSelection::FilterOutScraping:
            return passesScrapingFilter();
        case TTbarEPlusJetsSelection::HighLevelTrigger:
            return passesHighLevelTrigger();
        case TTbarEPlusJetsSelection::GoodPrimaryvertex:
            return hasOneGoodPrimaryVertex();
        case TTbarEPlusJetsSelection::OneIsolatedElectron:
            return hasOnlyOneGoodIsolatedElectron();
        case TTbarEPlusJetsSelection::ConversionRejection:
            return isolatedElectronDoesNotComeFromConversion();
        case TTbarEPlusJetsSelection::ConversionFinder:
            return isolatedElectronNotTaggedAsFromConversion();
        case TTbarEPlusJetsSelection::LooseMuonVeto:
            return hasNoIsolatedMuon();
        case TTbarEPlusJetsSelection::AtLeastOneGoodJets:
            return hasAtLeastOneGoodJet();
        case TTbarEPlusJetsSelection::AtLeastTwoGoodJets:
            return hasAtLeastTwoGoodJets();
        case TTbarEPlusJetsSelection::AtLeastThreeGoodJets:
            return hasAtLeastThreeGoodJets();
        case TTbarEPlusJetsSelection::AtLeastFourGoodJets:
            return hasAtLeastFourGoodJets();
        case TTbarEPlusJetsSelection::Zveto:
            return isNotAZBosonEvent();
        default:
            return false;
    }
}

}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/CrossSections.cpp
//***********************************************************************


/*
 * CrossSections.cpp
 *
 *  Created on: 13 Aug 2010
 *      Author: kreczko
 */

#include "../interface/CrossSections.h"

namespace BAT {

boost::array<float, DataType::NUMBER_OF_DATA_TYPES> sevenTeV::getXSections() {
    boost::array<float, DataType::NUMBER_OF_DATA_TYPES> xsection;
    xsection[DataType::DATA] = 0;
    xsection[DataType::ttbar] = 157.5;
    xsection[DataType::Zjets] = 3048.;
    xsection[DataType::Wjets] = 31314.;

    xsection[DataType::QCD_EMEnriched_Pt20to30] = 0.2355e9 * 0.0073;//xs 0.2355 mb (filter efficiency=0.0073)
    xsection[DataType::QCD_EMEnriched_Pt30to80] = 0.0593e9 * 0.059; //xs 0.0593 mb
    xsection[DataType::QCD_EMEnriched_Pt80to170] = 0.906e6 * 0.148; //xs 0.906e-3 mb

    xsection[DataType::QCD_BCtoE_Pt20to30] = 0.2355e9 * 0.00046; //xs 0.2355 mb (filter efficiency=0.00046)
    xsection[DataType::QCD_BCtoE_Pt30to80] = 0.0593e9 * 0.00234; //xs 0.0593 mb
    xsection[DataType::QCD_BCtoE_Pt80to170] = 0.906e6 * 0.0104; //xs 0.906e-3 mb

    xsection[DataType::PhotonJets_Pt40to100] = 23620.; //pb
    xsection[DataType::PhotonJets_Pt100to200] = 3476.; //pb
    xsection[DataType::PhotonJets_Pt200toInf] = 485.; //pb

    xsection[DataType::singleTop_And_W] = 10.6; //xs  11 pb (NLO MCFM) inclusive t,W decay
    xsection[DataType::singleTopTChannel] = 21.53; //=64.6/3 15Jul
    xsection[DataType::singleTopSChannel] = 1.40; //=4.21/3 15Jul
    xsection[DataType::VQQ] = 36.;
    xsection[DataType::Zprime_M500GeV_W5GeV] = 50;
    xsection[DataType::Zprime_M500GeV_W50GeV] = 50;
    xsection[DataType::Zprime_M750GeV_W7500MeV] = 50;
    xsection[DataType::Zprime_M1TeV_W10GeV] = 50;
    xsection[DataType::Zprime_M1TeV_W100GeV] = 50;
    xsection[DataType::Zprime_M1250GeV_W12500MeV] = 50;
    xsection[DataType::Zprime_M1500GeV_W15GeV] = 50;
    xsection[DataType::Zprime_M1500GeV_W150GeV] = 50;
    xsection[DataType::Zprime_M2TeV_W20GeV] = 50;
    xsection[DataType::Zprime_M2TeV_W200GeV] = 50;
    xsection[DataType::Zprime_M3TeV_W30GeV] = 50;
    xsection[DataType::Zprime_M3TeV_W300GeV] = 50;
    xsection[DataType::Zprime_M4TeV_W40GeV] = 50;
    xsection[DataType::Zprime_M4TeV_W400GeV] = 50;
    return xsection;
}

CrossSectionProvider::CrossSectionProvider(float lumiInInversePb, unsigned short tev) :
    lumiInInversePb(lumiInInversePb), tev(tev), useSkimEff(true), xsection(), numberOfProducedEvents(),
            numberOfSkimmedEvents() {
    if (tev == 7)
        xsection = sevenTeV::getXSections();
    defineNumberOfProducedEvents();
    defineNumberOfSkimmedEvents();
}

void CrossSectionProvider::defineNumberOfProducedEvents() {
    numberOfProducedEvents[DataType::DATA] = 0;
    numberOfProducedEvents[DataType::ttbar] = 1306182;
    numberOfProducedEvents[DataType::Zjets] = 2543727;
    numberOfProducedEvents[DataType::Wjets] = 14805546;

    numberOfProducedEvents[DataType::QCD_EMEnriched_Pt20to30] = 37169939;
    numberOfProducedEvents[DataType::QCD_EMEnriched_Pt30to80] = 71845473;
    numberOfProducedEvents[DataType::QCD_EMEnriched_Pt80to170] = 5546413;

    numberOfProducedEvents[DataType::QCD_BCtoE_Pt20to30] = 2243439;
    numberOfProducedEvents[DataType::QCD_BCtoE_Pt30to80] = 1995502;
    numberOfProducedEvents[DataType::QCD_BCtoE_Pt80to170] = 1043390;

    numberOfProducedEvents[DataType::PhotonJets_Pt40to100] = 2217101;
    numberOfProducedEvents[DataType::PhotonJets_Pt100to200] = 1065691;
    numberOfProducedEvents[DataType::PhotonJets_Pt200toInf] = 1142171;

    numberOfProducedEvents[DataType::singleTop_And_W] = 494961;
    numberOfProducedEvents[DataType::singleTopTChannel] = 484060;
    numberOfProducedEvents[DataType::singleTopSChannel] = 494967;
    numberOfProducedEvents[DataType::VQQ] = 720613;
    numberOfProducedEvents[DataType::Zprime_M500GeV_W5GeV] = 227068;
    numberOfProducedEvents[DataType::Zprime_M500GeV_W50GeV] = 238963;
    numberOfProducedEvents[DataType::Zprime_M750GeV_W7500MeV] = 204819;
    numberOfProducedEvents[DataType::Zprime_M1TeV_W10GeV] = 213384;
    numberOfProducedEvents[DataType::Zprime_M1TeV_W100GeV] = 200387;
    numberOfProducedEvents[DataType::Zprime_M1250GeV_W12500MeV] = 233361;
    numberOfProducedEvents[DataType::Zprime_M1500GeV_W15GeV] = 193779;
    numberOfProducedEvents[DataType::Zprime_M1500GeV_W150GeV] = 199121;
    numberOfProducedEvents[DataType::Zprime_M2TeV_W20GeV] = 238752;
    numberOfProducedEvents[DataType::Zprime_M2TeV_W200GeV] = 213363;
    numberOfProducedEvents[DataType::Zprime_M3TeV_W30GeV] = 205270;
    numberOfProducedEvents[DataType::Zprime_M3TeV_W300GeV] = 229034;
    numberOfProducedEvents[DataType::Zprime_M4TeV_W40GeV] = 183920;
    numberOfProducedEvents[DataType::Zprime_M4TeV_W400GeV] = 238142;
}

void CrossSectionProvider::defineNumberOfSkimmedEvents() {
    numberOfSkimmedEvents[DataType::DATA] = 0;
    numberOfSkimmedEvents[DataType::ttbar] = 642707.;
    numberOfSkimmedEvents[DataType::Zjets] = 329061.;
    numberOfSkimmedEvents[DataType::Wjets] = 1101679.;

    numberOfSkimmedEvents[DataType::QCD_EMEnriched_Pt20to30] = 917274.;
    numberOfSkimmedEvents[DataType::QCD_EMEnriched_Pt30to80] = 3639776.;
    numberOfSkimmedEvents[DataType::QCD_EMEnriched_Pt80to170] = 1253958.;

    numberOfSkimmedEvents[DataType::QCD_BCtoE_Pt20to30] = 86392.;
    numberOfSkimmedEvents[DataType::QCD_BCtoE_Pt30to80] = 441537.;
    numberOfSkimmedEvents[DataType::QCD_BCtoE_Pt80to170] = 477762.;

    numberOfSkimmedEvents[DataType::PhotonJets_Pt40to100] = 311575;
    numberOfSkimmedEvents[DataType::PhotonJets_Pt100to200] = 241590;
    numberOfSkimmedEvents[DataType::PhotonJets_Pt200toInf] = 388407;

    numberOfSkimmedEvents[DataType::singleTop_And_W] = 0;
    numberOfSkimmedEvents[DataType::singleTopTChannel] = 0;
    numberOfSkimmedEvents[DataType::singleTopSChannel] = 0;
    numberOfSkimmedEvents[DataType::VQQ] = 36.;
    numberOfSkimmedEvents[DataType::Zprime_M500GeV_W5GeV] = 50;
    numberOfSkimmedEvents[DataType::Zprime_M500GeV_W50GeV] = 50;
    numberOfSkimmedEvents[DataType::Zprime_M750GeV_W7500MeV] = 50;
    numberOfSkimmedEvents[DataType::Zprime_M1TeV_W10GeV] = 50;
    numberOfSkimmedEvents[DataType::Zprime_M1TeV_W100GeV] = 50;
    numberOfSkimmedEvents[DataType::Zprime_M1250GeV_W12500MeV] = 50;
    numberOfSkimmedEvents[DataType::Zprime_M1500GeV_W15GeV] = 50;
    numberOfSkimmedEvents[DataType::Zprime_M1500GeV_W150GeV] = 50;
    numberOfSkimmedEvents[DataType::Zprime_M2TeV_W20GeV] = 50;
    numberOfSkimmedEvents[DataType::Zprime_M2TeV_W200GeV] = 50;
    numberOfSkimmedEvents[DataType::Zprime_M3TeV_W30GeV] = 50;
    numberOfSkimmedEvents[DataType::Zprime_M3TeV_W300GeV] = 50;
    numberOfSkimmedEvents[DataType::Zprime_M4TeV_W40GeV] = 50;
    numberOfSkimmedEvents[DataType::Zprime_M4TeV_W400GeV] = 50;
}

CrossSectionProvider::~CrossSectionProvider() {

}

void CrossSectionProvider::useSkimEfficiency(bool use) {
    useSkimEff = use;
}

float CrossSectionProvider::getExpectedNumberOfEvents(DataType::value type) {
    if (useSkimEff)
        return xsection[type] * lumiInInversePb * numberOfSkimmedEvents[type] / numberOfProducedEvents[type];
    else
        return xsection[type] * lumiInInversePb;
}

float CrossSectionProvider::getWeight(DataType::value type) {
    if (type == DataType::DATA)
        return 1.;
    else
        return xsection[type] * lumiInInversePb / numberOfProducedEvents[type];
}

} // namespace BAT


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/HistHelpers/HistogramManager.cpp
//***********************************************************************


/*
 * HistogramManager.cpp
 *
 *  Created on: 4 Jul 2010
 *      Author: kreczko
 */

#include "../../interface/HistHelpers/HistogramManager.h"
#include "../../interface/Readers/NTupleEventReader.h"

namespace BAT {

HistogramManager::HistogramManager() :
    jetBinned1DHists(boost::extents[DataType::NUMBER_OF_DATA_TYPES][JetBin::NUMBER_OF_JET_BINS]),
    jetBinned1DHistNames(),
    jetBinned2DHists(boost::extents[DataType::NUMBER_OF_DATA_TYPES][JetBin::NUMBER_OF_JET_BINS]),
    jetBinned2DHistNames(),
    bJetBinned1DHists(boost::extents[DataType::NUMBER_OF_DATA_TYPES][BJetBin::NUMBER_OF_BJET_BINS]),
    bJetBinned1DHistNames(),
    bJetBinned2DHists(boost::extents[DataType::NUMBER_OF_DATA_TYPES][BJetBin::NUMBER_OF_BJET_BINS]),
    bJetBinned2DHistNames(),
    seenDataTypes(),
    histFiles(),
    collection(),
    collection1DHistNames(),
    collection2D(),
    collection2DHistNames(),
    currentDataType(DataType::DATA),
    currentJetbin(0),
    currentBJetbin(0),
    currentIntegratedLumi(0) {
}

HistogramManager::~HistogramManager() {
}

void HistogramManager::addH1D(std::string name, std::string title, unsigned int numberOfBins, float xmin, float xmax) {
    for (unsigned short type = DataType::DATA; type < DataType::NUMBER_OF_DATA_TYPES; ++type) {
        if (seenDataTypes.at(type)) {
            collection[type]->add(name, title, numberOfBins, xmin, xmax);
            collection1DHistNames.push_back(name);
        }
    }
    collection1DHistNames.push_back(name);
}

void HistogramManager::addH1D_JetBinned(std::string name, std::string title, unsigned int numberOfBins, float xmin,
        float xmax) {
    for (unsigned short jetbin = 0; jetbin < JetBin::NUMBER_OF_JET_BINS; ++jetbin) {
        for (unsigned short type = DataType::DATA; type < DataType::NUMBER_OF_DATA_TYPES; ++type) {
            if (seenDataTypes.at(type)) {
                std::stringstream tmp_name, tmp_title;
//                tmp_name << name << "_" << JetBin::names[jetbin];
                tmp_title << title << " (" << JetBin::names[jetbin] << ")";
                jetBinned1DHists[type][jetbin]->add(name, tmp_title.str(), numberOfBins, xmin, xmax);
            }
        }
    }
    jetBinned1DHistNames.push_back(name);
}

void HistogramManager::addH1D_BJetBinned(std::string name, std::string title, unsigned int numberOfBins, float xmin,
        float xmax) {
    for (unsigned short jetbin = 0; jetbin < BJetBin::NUMBER_OF_BJET_BINS; ++jetbin) {
        for (unsigned short type = DataType::DATA; type < DataType::NUMBER_OF_DATA_TYPES; ++type) {
            if (seenDataTypes.at(type)) {
                std::stringstream tmp_title;
                tmp_title << title << " (" << BJetBin::names[jetbin] << ")";
                bJetBinned1DHists[type][jetbin]->add(name, tmp_title.str(), numberOfBins, xmin, xmax);
            }
        }
    }
    bJetBinned1DHistNames.push_back(name);
}

void HistogramManager::addH2D_BJetBinned(std::string name, std::string title, unsigned int nXBins, float xmin, float xmax,
        unsigned int nYBins, float ymin, float ymax) {
    for (unsigned short jetbin = 0; jetbin < BJetBin::NUMBER_OF_BJET_BINS; ++jetbin) {
        for (unsigned short type = DataType::DATA; type < DataType::NUMBER_OF_DATA_TYPES; ++type) {
            if (seenDataTypes.at(type)) {
                std::stringstream tmp_title;
                tmp_title << title << " (" << BJetBin::names[jetbin] << ")";
                bJetBinned2DHists[type][jetbin]->add(name, tmp_title.str(), nXBins, xmin, xmax, nYBins, ymin, ymax);
            }
        }
    }
    bJetBinned2DHistNames.push_back(name);
}

void HistogramManager::addH2D(std::string name, std::string title, unsigned int nXBins, float xmin, float xmax,
        unsigned int nYBins, float ymin, float ymax) {
    for (unsigned short type = DataType::DATA; type < DataType::NUMBER_OF_DATA_TYPES; ++type) {
        if (seenDataTypes.at(type)) {
            collection2D[type]->add(name, title, nXBins, xmin, xmax, nYBins, ymin, ymax);
        }
    }
    collection2DHistNames.push_back(name);
}

void HistogramManager::setCurrentDataType(DataType::value type) {
    currentDataType = type;
}

void HistogramManager::setCurrentJetBin(unsigned int jetbin) {
    if (jetbin > 3) {
        currentJetbin = 4;
    } else
        currentJetbin = jetbin;
}

void HistogramManager::setCurrentBJetBin(unsigned int jetbin) {
    if (jetbin > 3) {
        currentBJetbin = 4;
    } else
        currentBJetbin = jetbin;
}

void HistogramManager::setCurrentLumi(float lumi) {
    currentIntegratedLumi = lumi;
}

boost::shared_ptr<TH1> HistogramManager::operator [](std::string histname) {
    return collection[currentDataType]->get(histname);
}

boost::shared_ptr<TH1> HistogramManager::H1D(std::string histname) {
    return collection[currentDataType]->get(histname);
}

boost::shared_ptr<TH1> HistogramManager::H1D_JetBinned(std::string histname) {
    return jetBinned1DHists[currentDataType][currentJetbin]->get(histname);
}

boost::shared_ptr<TH1> HistogramManager::H1D_BJetBinned(std::string histname) {
    return bJetBinned1DHists[currentDataType][currentBJetbin]->get(histname);
}

boost::shared_ptr<TH2> HistogramManager::H2D_BJetBinned(std::string histname) {
    return bJetBinned2DHists[currentDataType][currentBJetbin]->get(histname);
}

boost::shared_ptr<TH2> HistogramManager::operator ()(std::string histname) {
    return collection2D[currentDataType]->get(histname);
}

boost::shared_ptr<TH2> HistogramManager::H2D(std::string histname) {
    return collection2D[currentDataType]->get(histname);
}

void HistogramManager::createAllHistograms() {
    collection[DataType::DATA]->add("mttbar", "mttbar", 5000, 0, 5000);
}

void HistogramManager::prepareForSeenDataTypes(const boost::array<bool, DataType::NUMBER_OF_DATA_TYPES>& seenDataTypes) {
    this->seenDataTypes = seenDataTypes;
    for (unsigned type = 0; type < DataType::NUMBER_OF_DATA_TYPES; ++type) {
        if (seenDataTypes.at(type)) {
            const std::string filename = assembleFilename((DataType::value) type);
            boost::shared_ptr<TFile> file(new TFile(filename.c_str(), "RECREATE"));
            file->SetCompressionLevel(7);
            histFiles.at(type) = file;
            collection.at(type) = TH1CollectionRef(new TH1Collection());
            collection2D.at(type) = TH2CollectionRef(new TH2Collection());
            for (unsigned short jetbin = 0; jetbin < JetBin::NUMBER_OF_JET_BINS; ++jetbin) {
                TH1CollectionRef coll(new TH1Collection());
                coll->setSuffix(JetBin::names.at(jetbin));
                jetBinned1DHists[type][jetbin] = coll;
            }

            for (unsigned short jetbin = 0; jetbin < BJetBin::NUMBER_OF_BJET_BINS; ++jetbin) {
                TH1CollectionRef coll(new TH1Collection());
                TH2CollectionRef coll2D(new TH2Collection());
                coll->setSuffix(BJetBin::names.at(jetbin));
                coll2D->setSuffix(BJetBin::names.at(jetbin));
                bJetBinned1DHists[type][jetbin] = coll;
                bJetBinned2DHists[type][jetbin] = coll2D;
            }
        }

    }
}

const std::string HistogramManager::assembleFilename(DataType::value type) const {
    const std::string name = DataType::names[type];
    std::stringstream str;
    std::string electronAlgo = ElectronAlgorithm::names[NTupleEventReader::electronAlgorithm];
    std::string jetAlgo = JetAlgorithm::names[NTupleEventReader::jetAlgorithm];
    std::string metAlgo = METAlgorithm::names[NTupleEventReader::metAlgorithm];
    str << name << "_" << currentIntegratedLumi << "pb";
    str << "_" << electronAlgo << "_" << jetAlgo << "_" << metAlgo << ".root";
    return str.str();

}

void HistogramManager::writeToDisk() {
    for (unsigned type = 0; type < DataType::NUMBER_OF_DATA_TYPES; ++type) {
        if (seenDataTypes.at(type)) {
            createSummedHistograms((DataType::value) type);
            createJetSummedHistograms((DataType::value) type);
            createBJetSummedHistograms((DataType::value) type);

            collection.at(type)->writeToFile(histFiles.at(type));
            collection2D.at(type)->writeToFile(histFiles.at(type));
            for (unsigned short jetbin = 0; jetbin < JetBin::NUMBER_OF_JET_BINS; ++jetbin) {
                jetBinned1DHists[type][jetbin]->writeToFile(histFiles.at(type));
            }

            for (unsigned short jetbin = 0; jetbin < BJetBin::NUMBER_OF_BJET_BINS; ++jetbin) {
                bJetBinned1DHists[type][jetbin]->writeToFile(histFiles.at(type));
                bJetBinned2DHists[type][jetbin]->writeToFile(histFiles.at(type));
            }
            histFiles.at(type)->Write();
            histFiles.at(type)->Close();
        }

    }
}

void HistogramManager::createSummedHistograms(DataType::value type){

}

void HistogramManager::createJetSummedHistograms(DataType::value type){
    for (unsigned int nameIndex = 0; nameIndex < jetBinned1DHistNames.size(); ++nameIndex) {
        std::string name = jetBinned1DHistNames.at(nameIndex);
        for (unsigned short jetbinSum = 0; jetbinSum < JetBinSummed::NUMBER_OF_SUMMED_JET_BINS; ++jetbinSum) {
            std::stringstream tmp_name, tmp_title;
            tmp_name << name << "_" << JetBinSummed::names[jetbinSum];
            boost::shared_ptr<TH1> hist((TH1*)jetBinned1DHists[type][jetbinSum]->get(name)->Clone(tmp_name.str().c_str()));
            tmp_title << hist->GetTitle() << " (" << JetBinSummed::names[jetbinSum] << ")";
            hist->SetTitle(tmp_title.str().c_str());

            for (unsigned short jetbin = jetbinSum + 1; jetbin < JetBin::NUMBER_OF_JET_BINS; ++jetbin) {
                hist->Add(jetBinned1DHists[type][jetbin]->get(name).get());
            }
            collection[type]->add(tmp_name.str(), hist);
        }
    }
    for (unsigned int nameIndex = 0; nameIndex < jetBinned2DHistNames.size(); ++nameIndex) {
        std::string name = jetBinned2DHistNames.at(nameIndex);
        for (unsigned short jetbinSum = 0; jetbinSum < JetBinSummed::NUMBER_OF_SUMMED_JET_BINS; ++jetbinSum) {
            std::stringstream tmp_name, tmp_title;
            tmp_name << name << "_" << JetBinSummed::names[jetbinSum];
            boost::shared_ptr<TH2> hist((TH2*) jetBinned2DHists[type][jetbinSum]->get(name)->Clone(
                    tmp_name.str().c_str()));
            tmp_title << hist->GetTitle() << " (" << JetBinSummed::names[jetbinSum] << ")";
            hist->SetTitle(tmp_title.str().c_str());

            for (unsigned short jetbin = jetbinSum + 1; jetbin < JetBin::NUMBER_OF_JET_BINS; ++jetbin) {
                hist->Add(jetBinned2DHists[type][jetbin]->get(name).get());
            }
            collection2D[type]->add(tmp_name.str(), hist);
        }
    }
}

void HistogramManager::createBJetSummedHistograms(DataType::value type){
    for (unsigned int nameIndex = 0; nameIndex < bJetBinned1DHistNames.size(); ++nameIndex) {
        std::string name = bJetBinned1DHistNames.at(nameIndex);
        for (unsigned short jetbinSum = 0; jetbinSum < BJetBinSummed::NUMBER_OF_SUMMED_BJET_BINS; ++jetbinSum) {
            std::stringstream tmp_name, tmp_title;
            tmp_name << name << "_" << BJetBinSummed::names[jetbinSum];
            boost::shared_ptr<TH1> hist((TH1*) bJetBinned1DHists[type][jetbinSum]->get(name)->Clone(
                    tmp_name.str().c_str()));
            tmp_title << hist->GetTitle() << " (" << BJetBinSummed::names[jetbinSum] << ")";
            hist->SetTitle(tmp_title.str().c_str());

            for (unsigned short jetbin = jetbinSum + 1; jetbin < BJetBin::NUMBER_OF_BJET_BINS; ++jetbin) {
                hist->Add(bJetBinned1DHists[type][jetbin]->get(name).get());
            }
            collection[type]->add(tmp_name.str(), hist);
        }
    }
    for (unsigned int nameIndex = 0; nameIndex < bJetBinned2DHistNames.size(); ++nameIndex) {
        std::string name = bJetBinned2DHistNames.at(nameIndex);
        for (unsigned short jetbinSum = 0; jetbinSum < BJetBinSummed::NUMBER_OF_SUMMED_BJET_BINS; ++jetbinSum) {
            std::stringstream tmp_name, tmp_title;
            tmp_name << name << "_" << BJetBinSummed::names[jetbinSum];
            boost::shared_ptr<TH2> hist((TH2*) bJetBinned2DHists[type][jetbinSum]->get(name)->Clone(
                    tmp_name.str().c_str()));
            tmp_title << hist->GetTitle() << " (" << BJetBinSummed::names[jetbinSum] << ")";
            hist->SetTitle(tmp_title.str().c_str());

            for (unsigned short jetbin = jetbinSum + 1; jetbin < BJetBin::NUMBER_OF_BJET_BINS; ++jetbin) {
                hist->Add(bJetBinned2DHists[type][jetbin]->get(name).get());
            }
            collection2D[type]->add(tmp_name.str(), hist);
        }
    }
}

}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/HistHelpers/THCollection.cpp
//***********************************************************************


/*
 * THCollection.cpp
 *
 *  Created on: 9 Aug 2010
 *      Author: kreczko
 */

#include "../../interface/HistHelpers/THCollection.h"

namespace BAT {
template<>
void THCollection<TH1>::add(std::string name, std::string title, unsigned int numberOfBins, float xmin, float xmax) {
    histMap[name] = boost::shared_ptr<TH1>(new TH1F(name.c_str(), title.c_str(), numberOfBins, xmin, xmax));
}

template<>
void THCollection<TH2>::add(std::string name, std::string title, unsigned int numberOfXBins, float xmin, float xmax,
        unsigned int numberOfYBins, float ymin, float ymax) {
    histMap[name] = boost::shared_ptr<TH2>(new TH2F(name.c_str(), title.c_str(), numberOfXBins, xmin, xmax,
            numberOfYBins, ymin, ymax));
}
}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/HistHelpers/StringOperations.cpp
//***********************************************************************


/*
 * StringOperations.cpp
 *
 *  Created on: 11 Aug 2010
 *      Author: kreczko
 */

#include "../../interface/HistHelpers/StringOperations.h"
namespace BAT{
extern vector<string> getDirectoriesFromPath(string path) {

    vector<string> directories;
    if (path == "" || path == "/")
        return directories;

    if (path.find_last_of("/") == path.length() - 1) {
        path.erase(path.length() - 1);
    }

    if (path.find("/") == string::npos) {
        directories.push_back(path);
    } else {
        // Skip delimiters at beginning.
        string::size_type lastPos = path.find_first_not_of("/", 0);
        // Find first "non-delimiter".
        string::size_type pos = path.find_first_of("/", lastPos);

        while (string::npos != pos || string::npos != lastPos) {
            // Found a directory, add it to the vector.
            directories.push_back(path.substr(lastPos, pos - lastPos));
            // Skip delimiters.
            lastPos = path.find_first_not_of("/", pos);
            // Find next "non-delimiter"
            pos = path.find_first_of("/", lastPos);
        }
    }
    return directories;
}
}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/RecoObjects/Particle.cpp
//***********************************************************************


/*
 * Particle.cpp
 *
 *  Created on: 2 Jul 2010
 *      Author: kreczko
 */

#include "../../interface/RecoObjects/Particle.h"

namespace BAT {

Particle::Particle() :
    particleMass(0), particleCharge(0), distanceFromInteractionPointInMicron(999999),
            distanceFromInteractionPointInMicron_wrt_to_BeamSpot(999999), fourvector(0., 0., 0., 0.) {

}

Particle::Particle(const Particle& particle) :
    particleMass(particle.mass()), particleCharge(particle.charge()), distanceFromInteractionPointInMicron(
            particle.d0()), distanceFromInteractionPointInMicron_wrt_to_BeamSpot(particle.d0_wrtBeamSpot()), fourvector(
            particle.getFourVector()) {

}

Particle::Particle(float energy, float px, float py, float pz) :
    particleMass(0),
    particleCharge(0),
    distanceFromInteractionPointInMicron(99999),
    distanceFromInteractionPointInMicron_wrt_to_BeamSpot(999999),
    fourvector(px, py, pz, energy) {
}

Particle::~Particle() {
}

float Particle::mass() const {
    if (particleMass == 0)
        return massFromEnergyAndMomentum();
    else
        return particleMass;
}

float Particle::d0() const {
    return distanceFromInteractionPointInMicron;
}

float Particle::d0_wrtBeamSpot() const {
    return distanceFromInteractionPointInMicron_wrt_to_BeamSpot;
}

float Particle::energy() const {
    return fourvector.Energy();
}

float Particle::et() const {
    return fourvector.Et();
}

float Particle::px() const {
    return fourvector.Px();
}

float Particle::py() const {
    return fourvector.Py();
}

float Particle::pz() const {
    return fourvector.Pz();
}

float Particle::pt() const {
    return fourvector.Pt();
}

float Particle::eta() const {
    return fourvector.Eta();
}

float Particle::phi() const {
    return fourvector.Phi();
}

float Particle::theta() const {
    return fourvector.Theta();
}

float Particle::massFromEnergyAndMomentum() const {
    return fourvector.M();
}

float Particle::charge() const {
    return particleCharge;
}

void Particle::setMass(float mass) {
    particleMass = mass;
}

void Particle::setD0(float d0) {
    distanceFromInteractionPointInMicron = d0;
}

void Particle::setD0_wrtBeamSpot(float d0) {
    distanceFromInteractionPointInMicron_wrt_to_BeamSpot = d0;
}

const FourVector& Particle::getFourVector() const {
    return fourvector;
}

void Particle::setFourVector(FourVector vector) {
    fourvector = vector;
}

void Particle::setCharge(float charge) {
    particleCharge = charge;
}

Particle & Particle::operator =(const Particle &rightHandSide) {
    if (this == &rightHandSide)
        return *this;
    fourvector = rightHandSide.getFourVector();
//    particleMass = rightHandSide.mass();
    return *this;
}

const Particle Particle::operator +(const Particle &other) const {
    Particle result = *this;
    FourVector vector = result.getFourVector() + other.getFourVector();
    result.setFourVector(vector);
    result.setMass(0);
    result.setCharge(result.charge() + other.charge());
    return result;
}

bool Particle::isInBarrelRegion() const {
    return fabs(eta()) < 1.4442;
}

bool Particle::isInCrack() const {
  return !isInBarrelRegion() && !isInEndCapRegion();
}

bool Particle::isInEndCapRegion() const {
    return fabs(eta()) > 1.5660;
}

const char* Particle::getEtaRegion() const {
    if (isInBarrelRegion())
        return "barrel";
    else if (isInCrack())
        return "crack";
    else if (isInEndCapRegion())
        return "endcap";
    else
        return "unknown";
}

float Particle::deltaEta(const ParticlePointer other) const {
    return fabs(eta() - other->eta());
}

float Particle::deltaPhi(const ParticlePointer other) const {
    return fourvector.DeltaPhi(other->getFourVector());
}

float Particle::deltaR(const ParticlePointer other) const {
    return fourvector.DeltaR(other->getFourVector());
}

bool Particle::isWithinDeltaR(float delta_R, const ParticlePointer particle) const {
    return deltaR(particle) < delta_R;
}

float Particle::invariantMass(const ParticlePointer otherParticle) const {
    TLorentzVector combinedParticle(fourvector + otherParticle->getFourVector());
    return combinedParticle.M();
}

float Particle::relativePtTo(const ParticlePointer otherParticle) const {
    float relativePt = fourvector.Perp(otherParticle->getFourVector().Vect());
    return fabs(relativePt);
}

unsigned short Particle::getClosest(const ParticleCollection& particles) const {
    unsigned short idOfClosest = 999;
    float closestDR = 999.;
    for (unsigned short index = 0; index < particles.size(); ++index) {
        float DR = deltaR(particles.at(index));
        if (DR < closestDR) {
            closestDR = DR;
            idOfClosest = index;
        }
    }
    return idOfClosest;
}

float Particle::angle(const ParticlePointer otherParticle) const {
    return fourvector.Angle(otherParticle->getFourVector().Vect());
}
}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/RecoObjects/Jet.cpp
//***********************************************************************


/*
 * Jet.cpp
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#include "../../interface/RecoObjects/Jet.h"

namespace BAT {

Jet::Jet() :
    Particle(),
    usedAlgorithm(JetAlgorithm::Calo_AntiKT_Cone05),
    electromagneticFraction(0.),
    numberOfRecHitsContaining90PercentOfTheJetEnergy(0.),
    fractionOfEnergyIntheHottestHPDReadout(0.),
    btag_discriminators(BtagAlgorithm::NUMBER_OF_BTAGALGORITHMS),
    numberOfDaughters(0),
    chargedEmEnergyFraction(1),
    neutralHadronEnergyFraction(1),
    neutralEmEnergyFraction(1),
    chargedHadronEnergyFraction(1),
    chargedMultiplicity(0),
    partonFlavour(0) {
    for (unsigned int btag = 0; btag < btag_discriminators.size(); ++btag) {
        btag_discriminators[btag] = -9999;
    }
}

//Jet::Jet(const Particle& particle) :
//    Particle(particle),
//    usedAlgorithm(JetAlgorithm::Calo_AntiKT_Cone05),
//    electromagneticFraction(0.),
//    numberOfRecHitsContaining90PercentOfTheJetEnergy(0.),
//    fractionOfEnergyIntheHottestHPDReadout(0.),
//    btag_discriminators(BJetTagger::NUMBER_OF_BTAGALGORITHMS),
//    numberOfDaughters(0),
//    chargedEmEnergyFraction(1),
//    neutralHadronEnergyFraction(1),
//    neutralEmEnergyFraction(1),
//    chargedHadronEnergyFraction(1),
//    chargedMultiplicity(0) {
//
//}
Jet::Jet(float energy, float px, float py, float pz) :
    Particle(energy, px, py, pz),
    usedAlgorithm(JetAlgorithm::Calo_AntiKT_Cone05),
    electromagneticFraction(0.),
    btag_discriminators(BtagAlgorithm::NUMBER_OF_BTAGALGORITHMS),
    numberOfDaughters(0),
    chargedEmEnergyFraction(1),
    neutralHadronEnergyFraction(1),
    neutralEmEnergyFraction(1),
    chargedHadronEnergyFraction(1),
    chargedMultiplicity(0),
    partonFlavour(0) {
    for (unsigned int btag = 0; btag < btag_discriminators.size(); ++btag) {
        btag_discriminators[btag] = -9999;
    }

}

Jet::~Jet() {
}

JetAlgorithm::value Jet::getUsedAlgorithm() const {
    return usedAlgorithm;
}

float Jet::emf() const {
    return electromagneticFraction;
}

float Jet::n90Hits() const {
    return numberOfRecHitsContaining90PercentOfTheJetEnergy;
}

float Jet::fHPD() const {
    return fractionOfEnergyIntheHottestHPDReadout;
}

float Jet::NOD() const {
    return numberOfDaughters;
}

float Jet::CEF() const {
    return chargedEmEnergyFraction;
}

float Jet::NHF() const {
    return neutralHadronEnergyFraction;
}

float Jet::NEF() const {
    return neutralEmEnergyFraction;
}

float Jet::CHF() const {
    return chargedHadronEnergyFraction;
}

float Jet::NCH() const {
    return chargedMultiplicity;
}

void Jet::setUsedAlgorithm(JetAlgorithm::value algo) {
    usedAlgorithm = algo;
}
void Jet::setEMF(float emf) {
    electromagneticFraction = emf;
}

void Jet::setN90Hits(int n90Hits) {
    numberOfRecHitsContaining90PercentOfTheJetEnergy = n90Hits;
}

void Jet::setFHPD(float fHPD) {
    fractionOfEnergyIntheHottestHPDReadout = fHPD;
}

void Jet::setDiscriminatorForBtagType(float discriminator, BtagAlgorithm::value type) {
    btag_discriminators[type] = discriminator;
}

void Jet::setNOD(int nod) {
    numberOfDaughters = nod;
}
void Jet::setCEF(float cef) {
    chargedEmEnergyFraction = cef;
}
void Jet::setNHF(float nhf) {
    neutralHadronEnergyFraction = nhf;
}
void Jet::setNEF(float nef) {
    neutralEmEnergyFraction = nef;
}
void Jet::setCHF(float chf) {
    chargedHadronEnergyFraction = chf;
}
void Jet::setNCH(float nch) {
    chargedMultiplicity = nch;
}

bool Jet::isGood() const {
    bool passesPt = pt() > 30;
    bool passesEta = fabs(eta()) < 2.4;
    bool jetID = false;
    if (usedAlgorithm == JetAlgorithm::ParticleFlow || usedAlgorithm == JetAlgorithm::PF2PAT) {
        bool passNOD = NOD() > 1;
        bool passCEF = CEF() < 0.99;
        bool passNHF = NHF() < 0.99;
        bool passNEF = NEF() < 0.99;
        bool passCHF = true;
        bool passNCH = true;
        if (fabs(eta()) < 2.4) {
            passCHF = CHF() > 0;
            passNCH = NCH() > 0;
        }
        jetID = passNOD && passCEF && passNHF && passNEF && passCHF && passNCH;
    }
    else{
        bool passesEMF = emf() > 0.01;
        bool passesN90Hits = n90Hits() > 1;
        bool passesFHPD = fHPD() < 0.98;
        jetID = passesEMF && passesN90Hits && passesFHPD;
    }

    return passesPt && passesEta && jetID;
}

/* Values taken from
 * https://twiki.cern.ch/twiki/bin/view/CMSPublic/SWGuideBTagPerformance
 */
bool Jet::isBJet(BtagAlgorithm::value type, BtagAlgorithm::workingPoint wp) const {
    float cut(-9998);
    switch (type) {
    case BtagAlgorithm::GenPartonFlavour:
        return abs(partonFlavour) == 5;

    case BtagAlgorithm::SimpleSecondaryVertexHighEffBTag:
        if (wp == BtagAlgorithm::LOOSE)
            cut = -9998;//no input found
        else if (wp == BtagAlgorithm::MEDIUM)
            cut = 1.74;
        else if (wp == BtagAlgorithm::TIGHT)
            cut = 3.05;
        break;

    case BtagAlgorithm::SimpleSecondaryVertexHighPurBTag:
        if (wp == BtagAlgorithm::LOOSE)
            cut = -9998;//no input found
        else if (wp == BtagAlgorithm::MEDIUM)
            cut = -9998;//no input found
        else if (wp == BtagAlgorithm::TIGHT)
            cut = 2.;
        break;

    case BtagAlgorithm::TrackCountingHighEffBTag:
        if (wp == BtagAlgorithm::LOOSE)
            cut = 1.7;
        else if (wp == BtagAlgorithm::MEDIUM)
            cut = 3.3;
        else if (wp == BtagAlgorithm::TIGHT)
            cut = 10.2;
        break;

    case BtagAlgorithm::TrackCountingHighPurBTag:
        if (wp == BtagAlgorithm::LOOSE)
            cut = 1.19;
        else if (wp == BtagAlgorithm::MEDIUM)
            cut = 1.93;
        else if (wp == BtagAlgorithm::TIGHT)
            cut = 3.41;
        break;

    case BtagAlgorithm::JetProbabilityBTag:
        if (wp == BtagAlgorithm::LOOSE)
            cut = 0.215;
        else if (wp == BtagAlgorithm::MEDIUM)
            cut = 0.459;
        else if (wp == BtagAlgorithm::TIGHT)
            cut = 0.669;
        break;

    case BtagAlgorithm::JetBProbabilityBTag:
        if (wp == BtagAlgorithm::LOOSE)
            cut = 0.988;
        else if (wp == BtagAlgorithm::MEDIUM)
            cut = 1.83;
        else if (wp == BtagAlgorithm::TIGHT)
            cut = 1.95;
        break;
    default:
        return false;

    }
    return btag_discriminators[type] > cut;
}
}



//***********************************************************************
//***** src/OSUAnalysis/Tools/src/RecoObjects/Electron.cpp
//***********************************************************************


/*
 * Electron.cpp
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#include "../../interface/RecoObjects/Electron.h"
#include <assert.h>

namespace BAT {

const float initialBigValue = 123456789;
Electron::Electron() :
    Particle(),
    usedAlgorithm(ElectronAlgorithm::Calo),
    robustLooseId(false),
    robustTightId(false),
    superCluser_Eta(initialBigValue),
    ecal_Isolation(initialBigValue),
    hcal_Isolation(initialBigValue),
    tracker_Isolation(initialBigValue),
    innerLayerMissingHits_(initialBigValue),
    sigma_IEtaIEta(0),
    dPhi_In(0),
    dEta_In(0),
    hadOverEm(0),
    gsfTrack(),
    closesTrackID(-1),
    sharedFractionInnerHits(0),
    zDistanceToPrimaryVertex(initialBigValue),
    dCotThetaToNextTrack(0),
    distToNextTrack(0),
    PFGamma_Isolation(initialBigValue),
    PFChargedHadron_Isolation(initialBigValue),
    PFNeutralHadron_Isolation(initialBigValue){
}

Electron::Electron(float energy, float px, float py, float pz) :
    Particle(energy, px, py, pz),
    usedAlgorithm(ElectronAlgorithm::Calo),
    robustLooseId(false),
    robustTightId(false),
    superCluser_Eta(initialBigValue),
    ecal_Isolation(initialBigValue),
    hcal_Isolation(initialBigValue),
    tracker_Isolation(initialBigValue),
    innerLayerMissingHits_(initialBigValue),
    sigma_IEtaIEta(0),
    dPhi_In(0),
    dEta_In(0),
    hadOverEm(0),
    gsfTrack(),
    closesTrackID(-1),
    sharedFractionInnerHits(0),
    zDistanceToPrimaryVertex(initialBigValue),
    dCotThetaToNextTrack(0),
    distToNextTrack(0),
    PFGamma_Isolation(initialBigValue),
    PFChargedHadron_Isolation(initialBigValue),
    PFNeutralHadron_Isolation(initialBigValue){
}

Electron::~Electron() {
}

float Electron::superClusterEta() const {
    return superCluser_Eta;
}
float Electron::ecalIsolation() const {
    return ecal_Isolation;
}

float Electron::hcalIsolation() const {
    return hcal_Isolation;
}

float Electron::trackerIsolation() const {
    return tracker_Isolation;
}

float Electron::relativeIsolation() const {
    return (ecal_Isolation + hcal_Isolation + tracker_Isolation) / this->et();
}

bool Electron::isIsolated() const {
    return relativeIsolation() < 0.1;
}

bool Electron::isHEEPIsolated() const {
    if (isInBarrelRegion())
        return (ecal_Isolation + hcal_Isolation) < 2 + 0.03 * et();
    else if (isInEndCapRegion() && et() < 50)
        return (ecal_Isolation + hcal_Isolation) < 2.5;
    else if (isInEndCapRegion() && et() >= 50)
        return (ecal_Isolation + hcal_Isolation) < 2.5 + 0.03 * (et() - 50);
    else
        return false;
}

ElectronAlgorithm::value Electron::getUsedAlgorithm() const {
    return usedAlgorithm;
}

void Electron::setEcalIsolation(float isolation) {
    ecal_Isolation = isolation;
}

void Electron::setHcalIsolation(float isolation) {
    hcal_Isolation = isolation;
}

void Electron::setTrackerIsolation(float isolation) {
    tracker_Isolation = isolation;
}

void Electron::setSuperClusterEta(float eta) {
    superCluser_Eta = eta;
}

void Electron::setRobustLooseID(bool id) {
    robustLooseId = id;
}

void Electron::setRobustTightID(bool id) {
    robustTightId = id;
}

void Electron::setSigmaIEtaIEta(float sigma) {
    sigma_IEtaIEta = sigma;
}

void Electron::setDPhiIn(float dphi) {
    dPhi_In = dphi;
}

void Electron::setDEtaIn(float deta) {
    dEta_In = deta;
}

void Electron::setHadOverEm(float HoverE) {
    hadOverEm = HoverE;
}

bool Electron::isLoose() const {
    bool passesEt = et() > 20;
    bool passesEta = fabs(eta()) < 2.5;
    return passesEt && passesEta && VBTF_W95_ElectronID();

}

bool Electron::isGood(const float minEt) const {
    bool passesEt = et() > minEt;
    bool passesEta = fabs(eta()) < 2.5 && !isInCrack();

    bool passesD0 = false;
    if (usedAlgorithm == ElectronAlgorithm::Calo)
        passesD0 = fabs(d0_wrtBeamSpot()) < 0.02;//cm
    else
        // use d0 wrt primary vertex for
        passesD0 = fabs(d0()) < 0.01;//cm

    bool passesDistanceToPV = fabs(zDistanceToPrimaryVertex) < 1;
    bool passesID = VBTF_W70_ElectronID();
    return passesEt && passesEta && passesD0 && passesID && passesDistanceToPV;
}

bool Electron::isQCDElectron(const float minEt) const {
    bool passesEt = et() > minEt;
    bool passesEta = fabs(eta()) < 2.5 && !isInCrack();

    bool passesD0 = false;
    if (usedAlgorithm == ElectronAlgorithm::Calo)
        passesD0 = fabs(d0_wrtBeamSpot()) < 0.02;//cm
    else
        passesD0 = fabs(d0()) < 0.02;//cm

    bool passesDistanceToPV = fabs(zDistanceToPrimaryVertex) < 1;
    bool passesID = QCD_AntiID_W70();
    return passesEt && passesEta && passesD0 && passesID && passesDistanceToPV;
}

bool Electron::isInBarrelRegion() const {
    return fabs(superClusterEta()) < 1.4442;
}

bool Electron::isInCrack() const {
    return !isInBarrelRegion() && !isInEndCapRegion();
}

bool Electron::isInEndCapRegion() const {
    return fabs(superClusterEta()) > 1.5660;
}

bool Electron::isFromConversion() const {
    return innerLayerMissingHits_ > 0;
}

bool Electron::isTaggedAsConversion(float maxDist, float maxDCotTheta) const {
    return fabs(distToNextTrack) < maxDist && fabs(dCotThetaToNextTrack) < maxDCotTheta;
}

/* Electron ID cuts (without isolation) from:
 * https://twiki.cern.ch/twiki/bin/view/CMS/SimpleCutBasedEleID#Cuts_for_use_on_2010_data
 */
bool Electron::VBTF_W70_ElectronID() const {
    if (isInBarrelRegion())
        return getVBTF_W70_ElectronID_Barrel();
    else if (isInEndCapRegion())
        return getVBTF_W70_ElectronID_Endcap();
    else
        // in crack
        return false;
}

bool Electron::getVBTF_W70_ElectronID_Barrel() const {
    bool passesSigmaIEta = sigma_IEtaIEta < 0.01;
    bool passesDPhiIn = fabs(dPhi_In) < 0.03;
    bool passesDEtaIn = fabs(dEta_In) < 0.004;
    bool passesHadOverEm = hadOverEm < 0.025;
    return passesSigmaIEta && passesDPhiIn && passesDEtaIn && passesHadOverEm;
}

bool Electron::getVBTF_W70_ElectronID_Endcap() const {
    bool passesSigmaIEta = sigma_IEtaIEta < 0.03;
    bool passesDPhiIn = fabs(dPhi_In) < 0.02;
    bool passesDEtaIn = fabs(dEta_In) < 0.005;
    bool passesHadOverEm = hadOverEm < 0.025;
    return passesSigmaIEta && passesDPhiIn && passesDEtaIn && passesHadOverEm;
}

bool Electron::VBTF_W95_ElectronID() const {
    if (isInBarrelRegion())
        return getVBTF_W95_ElectronID_Barrel();
    else if (isInEndCapRegion())
        return getVBTF_W95_ElectronID_Endcap();
    else
        // in crack
        return false;
}

bool Electron::getVBTF_W95_ElectronID_Barrel() const {
    bool passesSigmaIEta = sigma_IEtaIEta < 0.01;
    bool passesDPhiIn = fabs(dPhi_In) < 0.8;
    bool passesDEtaIn = fabs(dEta_In) < 0.007;
    bool passesHadOverEm = hadOverEm < 0.15;
    return passesSigmaIEta && passesDPhiIn && passesDEtaIn && passesHadOverEm;
}

bool Electron::getVBTF_W95_ElectronID_Endcap() const {
    bool passesSigmaIEta = sigma_IEtaIEta < 0.03;
    bool passesDPhiIn = fabs(dPhi_In) < 0.7;
    bool passesDEtaIn = fabs(dEta_In) < 0.01;
    bool passesHadOverEm = hadOverEm < 0.07;
    return passesSigmaIEta && passesDPhiIn && passesDEtaIn && passesHadOverEm;
}

bool Electron::QCD_AntiID_W70() const {
    if (isInBarrelRegion())
        return QCD_AntiID_W70_Barrel();
    else if (isInEndCapRegion())
        return QCD_AntiID_W70_Endcap();
    else
        return false;
}

bool Electron::QCD_AntiID_W70_Barrel() const {
    bool passesSigmaIEta = sigma_IEtaIEta < 0.01;
    bool passesDPhiIn = fabs(dPhi_In) > 0.03;
    bool passesDEtaIn = fabs(dEta_In) > 0.004;
    bool passesHadOverEm = hadOverEm < 0.025;
    return passesSigmaIEta && passesDPhiIn && passesDEtaIn && passesHadOverEm;
}

bool Electron::QCD_AntiID_W70_Endcap() const {
    bool passesSigmaIEta = sigma_IEtaIEta < 0.03;
    bool passesDPhiIn = fabs(dPhi_In) > 0.02;
    bool passesDEtaIn = fabs(dEta_In) > 0.005;
    bool passesHadOverEm = hadOverEm < 0.025;
    return passesSigmaIEta && passesDPhiIn && passesDEtaIn && passesHadOverEm;
}

float Electron::sigmaIEtaIEta() const {
    return sigma_IEtaIEta;
}

float Electron::dPhiIn() const {
    return dPhi_In;
}

float Electron::dEtaIn() const {
    return dEta_In;
}

float Electron::HadOverEm() const {
    return hadOverEm;
}

float Electron::HEEPet() const {
    return energy() * sin(fourvector.Theta());
}

bool Electron::RobustLooseID() const {
    return robustLooseId;
}

bool Electron::RobustTightID() const {
    return robustTightId;
}

void Electron::setNumberOfMissingInnerLayerHits(float missingHits) {
    innerLayerMissingHits_ = missingHits;
}

unsigned short Electron::getClosestJetIndex(const JetCollection& jets) const {
    unsigned short idOfClosest = 999;
    float closestDR = 999.;
    for (unsigned short index = 0; index < jets.size(); ++index) {
        float DR = deltaR(jets.at(index));
        if (DR < closestDR) {
            closestDR = DR;
            idOfClosest = index;
        }
    }
    return idOfClosest;
}

void Electron::setUsedAlgorithm(ElectronAlgorithm::value algo) {
    usedAlgorithm = algo;
}

void Electron::setGSFTrack(const TrackPointer track) {
    gsfTrack = track;
}

const TrackPointer Electron::GSFTrack() const {
    return gsfTrack;
}

void Electron::setClosestTrackID(int trackID) {
    closesTrackID = trackID;
}

int Electron::closestCTFTrackID() const {
    return closesTrackID;
}

void Electron::setSharedFractionInnerHits(float hits) {
    sharedFractionInnerHits = hits;
}

float Electron::shFracInnerLayer() const {
    return sharedFractionInnerHits;
}

void Electron::setZDistanceToPrimaryVertex(float dist) {
    zDistanceToPrimaryVertex = dist;
}

void Electron::setDistToNextTrack(float dist) {
    distToNextTrack = dist;
}

void Electron::setDCotThetaToNextTrack(float dCotTheta) {
    dCotThetaToNextTrack = dCotTheta;
}

void Electron::setPFGammaIsolation(float pfGammaIso) {
    PFGamma_Isolation = pfGammaIso;
}

void Electron::setPFChargedHadronIsolation(float chargedHadronIso) {
    PFChargedHadron_Isolation = chargedHadronIso;
}

void Electron::setPFNeutralHadronIsolation(float neutralHadronIso) {
    PFNeutralHadron_Isolation = neutralHadronIso;
}

float Electron::PFGammaIsolation() const {
    return PFGamma_Isolation;
}

float Electron::PFChargedHadronIsolation() const {
    return PFChargedHadron_Isolation;
}

float Electron::PFNeutralHadronIsolation() const {
    return PFNeutralHadron_Isolation;
}

float Electron::pfIsolation() const {
    return (PFGamma_Isolation + PFChargedHadron_Isolation + PFNeutralHadron_Isolation) / et();
}

bool Electron::isPFIsolated() const {
    return pfIsolation() < 0.1;
}

float Electron::ZDistanceToPrimaryVertex() const {
    return zDistanceToPrimaryVertex;
}

ElectronAlgorithm::value Electron::algorithm() const {
    return usedAlgorithm;
}

float Electron::innerLayerMissingHits() const {
    return innerLayerMissingHits_;
}

float Electron::distToClosestTrack() const {
    return distToNextTrack;
}

float Electron::dCotThetaToClosestTrack() const {
    return dCotThetaToNextTrack;
}

}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/RecoObjects/Vertex.cpp
//***********************************************************************


/*
 * PrimaryVertex.cpp
 *
 *  Created on: 25 Jul 2010
 *      Author: kreczko
 */

#include "../../interface/RecoObjects/Vertex.h"
#include <math.h>
namespace BAT {

Vertex::Vertex() :
  is_fake(false), degreesOfFreedom(0), z_position(0), rho(0) {

}

Vertex::~Vertex() {
}

void Vertex::setDegreesOfFreedom(unsigned int ndof) {
  degreesOfFreedom = ndof;
}

void Vertex::setZPosition(float z) {
  z_position = z;
}

void Vertex::setRho(float rho) {
  this->rho = rho;
}

void Vertex::setFake(bool fake) {
  is_fake = fake;
}

unsigned int Vertex::ndof() const {
  return degreesOfFreedom;
}

float Vertex::absoluteZPosition() const {
  return fabs(z_position);
}

float Vertex::absoluteRho() const {
  return fabs(rho);
}

bool Vertex::isFake() const {
  return is_fake;
}

bool Vertex::isGood() const {
  bool passesNDOF = ndof() >= 4;
  bool passesZ = absoluteZPosition() <= 24;//cm
  bool passesRho = absoluteRho() <= 2.0;
  bool isNotFake = isFake() == false;
  return passesNDOF && passesZ && passesRho && isNotFake;
}

float Vertex::z() const{
    return z_position;
}
}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/RecoObjects/Photon.cpp
//***********************************************************************


/*
 * Photon.cpp
 *
 *  Created on: 2 Jul 2010
 *      Author: kreczko
 */

#include "../../interface/RecoObjects/Photon.h"

namespace BAT {

Photon::Photon() {
  // TODO Auto-generated constructor stub

}

Photon::~Photon() {
  // TODO Auto-generated destructor stub
}

}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/RecoObjects/PseudoParticle.cpp
//***********************************************************************


/*
 * PseudoParticle.cpp
 *
 *  Created on: 28 Sep 2010
 *      Author: kreczko
 */

#include "../../interface/RecoObjects/PseudoParticle.h"

namespace BAT {

PseudoParticle::PseudoParticle() :
    Phi(99999), Eta(-9999), Pt(0), Theta(0), D0(9999), Charge(-5555) {

}

PseudoParticle::PseudoParticle(float phi, float eta, float pt, float theta) :
    Phi(phi), Eta(eta), Pt(pt), Theta(theta), D0(9999), Charge(-5555) {

}

PseudoParticle::~PseudoParticle() {
}

void PseudoParticle::setPhi(float phi) {
    Phi = phi;
}

void PseudoParticle::setEta(float eta) {
    Eta = eta;
}

void PseudoParticle::setPt(float pt) {
    Pt = pt;
}

void PseudoParticle::setTheta(float theta) {
    Theta = theta;
}

void PseudoParticle::setD0(float d0) {
    D0 = d0;
}

void PseudoParticle::setCharge(float charge) {
    Charge = charge;
}

float PseudoParticle::phi() const {
    return Phi;
}

float PseudoParticle::eta() const {
    return Eta;
}

float PseudoParticle::pt() const {
    return Pt;
}

float PseudoParticle::theta() const {
    return Theta;
}

float PseudoParticle::d0() const {
    return D0;
}

float PseudoParticle::charge() const {
    return Charge;
}

float PseudoParticle::deltaR(const PseudoParticlePointer otherParticle) const {
    return deltaR(Phi, Eta, otherParticle->phi(), otherParticle->eta());
}

float PseudoParticle::deltaR(const ParticlePointer otherParticle) const {
    return deltaR(Phi, Eta, otherParticle->phi(), otherParticle->eta());
}

float PseudoParticle::deltaR(float phi1, float eta1, float phi2, float eta2) const {
    return sqrt(pow(deltaPhi(phi1, phi2), 2) + pow(deltaEta(eta1, eta2), 2));
}

float PseudoParticle::deltaPhi(float phi1, float phi2) const {
    float delPhi(999.0);
    delPhi = fabs(phi1 - phi2);
    if (delPhi > TMath::Pi())
        delPhi = 2.0 * TMath::Pi() - delPhi;
    return delPhi;
}

float PseudoParticle::deltaEta(float eta1, float eta2) const{
    return eta1 - eta2;
}

bool PseudoParticle::isWithinDeltaR(float delta_R, const PseudoParticlePointer particle) const{
    return deltaR(particle) < delta_R;
}

}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/RecoObjects/Muon.cpp
//***********************************************************************


/*
 * Muon.cpp
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#include "../../interface/RecoObjects/Muon.h"

namespace BAT {

Muon::Muon() :
  Particle(), is_Global(false), ecal_Isolation(0.), hcal_Isolation(0), tracker_Isolation(0) {

}

Muon::Muon(float energy, float px, float py, float pz) :
  Particle(energy, px, py, pz), is_Global(false), ecal_Isolation(0.), hcal_Isolation(0), tracker_Isolation(0) {

}

Muon::~Muon() {
}

bool Muon::isGlobal() const {
  return is_Global;
}

void Muon::makeGlobal(bool global) {
  is_Global = global;
}

float Muon::ecalIsolation() const {
  return ecal_Isolation;
}

void Muon::setEcalIsolation(float isolation) {
  ecal_Isolation = isolation;
}

float Muon::hcalIsolation() const {
  return hcal_Isolation;
}

void Muon::setHcalIsolation(float isolation) {
  hcal_Isolation = isolation;
}

float Muon::trackerIsolation() const {
  return tracker_Isolation;
}

void Muon::setTrackerIsolation(float isolation) {
  tracker_Isolation = isolation;
}

float Muon::relativeIsolation() const {
  return (ecal_Isolation + hcal_Isolation + tracker_Isolation) / pt();
}

bool Muon::isIsolated() const{
  return relativeIsolation() < 0.2;
}

bool Muon::isGood() const{
  bool passesPt = pt() > 10;
  bool passesEta = fabs(eta()) < 2.5;
  return passesPt && passesEta && is_Global;
}
}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/RecoObjects/Track.cpp
//***********************************************************************


/*
 * Track.cpp
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#include "../../interface/RecoObjects/Track.h"

namespace BAT {
const double Track::BFIELD = 3.8;

Track::Track() :
    PseudoParticle(), highPurity(false) {

}

Track::Track(const Track& track) :
    PseudoParticle((PseudoParticle) track), highPurity(track.highPurity) {

}

Track::Track(float phi, float eta, float pt, float theta) :
    PseudoParticle(phi, eta, pt, theta), highPurity(false) {

}

Track::~Track() {
}

double Track::curvature(double BField) const {
    return -0.3 * BField * charge() / pt() / 100.;
}

double Track::radius(double Bfield) const {
    return fabs(1 / curvature(Bfield));
}

double Track::x(double Bfield) const {
    return (1/curvature(Bfield) - d0()) * cos(phi());
}

double Track::y(double Bfield) const {
    return (1/curvature(Bfield) - d0()) * sin(phi());
}

double Track::deltaCotTheta(const TrackPointer otherTrack) const {
    return fabs(1 / tan(theta()) - 1 / tan(otherTrack->theta()));
}

double Track::distance(const TrackPointer otherTrack, double BField) const {
    double dx = x(BField) - otherTrack->x(BField);
    double dy = y(BField) - otherTrack->y(BField);
    double dist = sqrt(pow(dx, 2) + pow(dy, 2));
    return fabs(dist - (radius(BField) + otherTrack->radius(BField)));
}

void Track::setHighPurity(bool isPure) {
    highPurity = isPure;
}

bool Track::isHighPurity() const {
    return highPurity;
}

}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/RecoObjects/MCParticle.cpp
//***********************************************************************


/*
 * MCParticle.cpp
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#include "../../interface/RecoObjects/MCParticle.h"

namespace BAT {

MCParticle::MCParticle() : Particle(),
  particlePdgId(0), particleMotherIndex(0), particleStatus(0){

}

MCParticle::MCParticle(float energy, float px, float py, float pz): Particle(energy, px, py, pz),
    particlePdgId(0), particleMotherIndex(0), particleStatus(0){

}
//MCParticle::Particle(const MCParticle& particle) :
//  particlePdgId(particle.pdgId()), particleMotherIndex(particle.motherIndex()), particleStatus(particle.status) {
//
//}

//MCParticle::Particle(int pdgId, float phi, float eta, float pt, float energy, int motherIndex, int status) {
//
//}

//MCParticle::Particle(): Particle() {
//
//}

MCParticle::~MCParticle() {
}

int MCParticle::pdgId() const {
  return particlePdgId;
}

int MCParticle::motherIndex() const {
  return particleMotherIndex;
}

int MCParticle::status() const {
  return particleStatus;
}

void MCParticle::setStatus(int Status) {
  particleStatus = Status;
}

void MCParticle::setMotherIndex(int MotherIndex){
  particleMotherIndex = MotherIndex;
}

void MCParticle::setPdgId(int PdgId){
  particlePdgId = PdgId;
}

bool MCParticle::isQuark() const {
  if ((abs(pdgId())>0) && (abs(pdgId())<9)) return true; else return false;
}

bool MCParticle::isLepton() const {
  if ((abs(pdgId())>10) && (abs(pdgId())<19)) return true; else return false;
}

bool MCParticle::isNeutrino() const {
  if ((abs(pdgId())==12) || (abs(pdgId())==14) || (abs(pdgId())==16) || (abs(pdgId())==18)) return true; else return false;
}

unsigned short MCParticle::getClosestJetIndex(const JetCollection& jets) const {
    unsigned short idOfClosest = 999;
    float closestDR = 999.;
    for (unsigned short index = 0; index < jets.size(); ++index) {
        float DR = deltaR(jets.at(index));
        if (DR < closestDR) {
            closestDR = DR;
            idOfClosest = index;
        }
    }
    return idOfClosest;
}

}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/RecoObjects/MET.cpp
//***********************************************************************


/*
 * MET.cpp
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#include "../../interface/RecoObjects/MET.h"

namespace BAT {


MET::MET() :
    Particle(),
    usedAlgorithm(METAlgorithm::Calo) {
}

MET::MET(float ex, float ey) :
    Particle(sqrt(ex * ex + ey * ey), ex, ey, 0), usedAlgorithm(METAlgorithm::Calo) {

}

MET::~MET() {
}

bool MET::isGood() const {
    return et() > 20;
}

void MET::setUsedAlgorithm(METAlgorithm::value algo) {
    usedAlgorithm = algo;
}

METAlgorithm::value MET::getUsedAlgorithm() const {
    return usedAlgorithm;
}

}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/Readers/ElectronReader.cpp
//***********************************************************************


/*
 * ElectronReader.cpp
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#include "../../interface/Readers/ElectronReader.h"
namespace BAT {

//const std::string ElectronReader::algorithmPrefixes[Electron::NUMBER_OF_ELECTRONALGORITHMS] = { "els", "PFElsAll" };

ElectronReader::ElectronReader() :
//    numberOfElectronsReader(),
    energyReader(),
    pxReader(),
    pyReader(),
    pzReader(),
    chargeReader(),
    superClusterEtaReader(),
    d0_BS_Reader(),
    d0_PV_Reader(),
    numberOfInnerLayerMissingHitsReader(),
    ecalIsolationReader(),
    hcalIsolationReader(),
    trackerIsolationReader(),
    PFGammaIsolationReader(),
    PFChargedHadronIsolationReader(),
    PFNeutralHadronIsolationReader(),
//    robustLooseIDReader(),
//    robustTightIDReader(),
    sigmaIEtaIEtaReader(),
    dPhiInReader(),
    dEtaInReader(),
    hadOverEmReader(),
    sharedFractionInnerHits(),
    trackIDReader(),
    track_phi(),
    track_eta(),
    track_pt(),
    track_theta(),
    track_charge(),
    vertex_dist_z(),
    dist(),
    dCotTheta(),
    algorithm(ElectronAlgorithm::Calo),
    electrons() {

}

ElectronReader::ElectronReader(TChainPointer input, ElectronAlgorithm::value algo) :
//    numberOfElectronsReader(input, "N" + ElectronAlgorithm::prefixes.at(algo)),
    energyReader(input, ElectronAlgorithm::prefixes.at(algo) + ".Energy"),
    pxReader(input, ElectronAlgorithm::prefixes.at(algo) + ".Px"),
    pyReader(input, ElectronAlgorithm::prefixes.at(algo) + ".Py"),
    pzReader(input, ElectronAlgorithm::prefixes.at(algo) + ".Pz"),
    chargeReader(input, ElectronAlgorithm::prefixes.at(algo) + ".Charge"),
    superClusterEtaReader(input, ElectronAlgorithm::prefixes.at(algo) + ".SCEta"),
    d0_BS_Reader(input, ElectronAlgorithm::prefixes.at(algo) + ".dBBS"),
    d0_PV_Reader(input, ElectronAlgorithm::prefixes.at(algo) + ".dB"),
    numberOfInnerLayerMissingHitsReader(input, ElectronAlgorithm::prefixes.at(algo) + ".MissingHits"),
    ecalIsolationReader(input, ElectronAlgorithm::prefixes.at(algo) + ".EcalIso03"),
    hcalIsolationReader(input, ElectronAlgorithm::prefixes.at(algo) + ".HcalIso03"),
    trackerIsolationReader(input,ElectronAlgorithm::prefixes.at(algo) + ".TrkIso03"),
    PFGammaIsolationReader(input,ElectronAlgorithm::prefixes.at(algo) + ".PFGammaIso"),
    PFChargedHadronIsolationReader(input,ElectronAlgorithm::prefixes.at(algo) + ".PfChargedHadronIso"),
    PFNeutralHadronIsolationReader(input,ElectronAlgorithm::prefixes.at(algo) + ".PfNeutralHadronIso"),
//    robustLooseIDReader(input, ElectronAlgorithm::prefixes.at(algo) + ".robustLooseId"),
//    robustTightIDReader(input, ElectronAlgorithm::prefixes.at(algo) + ".robustTightId"),
    sigmaIEtaIEtaReader(input, ElectronAlgorithm::prefixes.at(algo) + ".SigmaIEtaIEta"),
    dPhiInReader(input, ElectronAlgorithm::prefixes.at(algo) + ".DeltaPhiTrkSC"),
    dEtaInReader(input, ElectronAlgorithm::prefixes.at(algo) + ".DeltaEtaTrkSC"),
    hadOverEmReader(input, ElectronAlgorithm::prefixes.at(algo) + ".HoE"),
    sharedFractionInnerHits(input, ElectronAlgorithm::prefixes.at(algo) + ".shFracInnerHits"),
    trackIDReader(input, ElectronAlgorithm::prefixes.at(algo) + ".closestCtfTrackRef"),
    track_phi(input, ElectronAlgorithm::prefixes.at(algo) + ".GSFTrack.Phi"),
    track_eta(input, ElectronAlgorithm::prefixes.at(algo) + ".GSFTrack.Eta"),
    track_pt(input, ElectronAlgorithm::prefixes.at(algo) + ".GSFTrack.Pt"),
    track_theta(input, ElectronAlgorithm::prefixes.at(algo) + ".GSFTrack.Theta"),
    track_charge(input, ElectronAlgorithm::prefixes.at(algo) + ".GSFTrack.Charge"),
    vertex_dist_z(input, ElectronAlgorithm::prefixes.at(algo) + ".VtxDistZ"),
    dist(input, ElectronAlgorithm::prefixes.at(algo) + ".Dist"),
    dCotTheta(input, ElectronAlgorithm::prefixes.at(algo) + ".DCotTheta"),
    algorithm(algo),
    electrons() {

}

ElectronReader::~ElectronReader() {
}

const ElectronCollection& ElectronReader::getElectrons() {
    if (electrons.empty() == false)
        electrons.clear();
    readElectrons();
    return electrons;
}

void ElectronReader::readElectrons() {
//    unsigned int numberOfElectrons = numberOfElectronsReader.getVariable();
    for (unsigned int index = 0; index < energyReader.size(); index++) {
        float energy = energyReader.getVariableAt(index);
        float px = pxReader.getVariableAt(index);
        float py = pyReader.getVariableAt(index);
        float pz = pzReader.getVariableAt(index);
        ElectronPointer electron(new Electron(energy, px, py, pz));
        electron->setUsedAlgorithm(algorithm);
        electron->setCharge(chargeReader.getIntVariableAt(index));
        if(d0_BS_Reader.doesVariableExist() && algorithm == ElectronAlgorithm::Calo)
            electron->setD0_wrtBeamSpot(d0_BS_Reader.getVariableAt(index));
        electron->setD0(d0_PV_Reader.getVariableAt(index));
        electron->setZDistanceToPrimaryVertex(vertex_dist_z.getVariableAt(index));
        electron->setNumberOfMissingInnerLayerHits(numberOfInnerLayerMissingHitsReader.getIntVariableAt(index));
        electron->setEcalIsolation(ecalIsolationReader.getVariableAt(index));
        electron->setHcalIsolation(hcalIsolationReader.getVariableAt(index));
        electron->setTrackerIsolation(trackerIsolationReader.getVariableAt(index));
        electron->setSuperClusterEta(superClusterEtaReader.getVariableAt(index));
        electron->setSigmaIEtaIEta(sigmaIEtaIEtaReader.getVariableAt(index));
        electron->setDPhiIn(dPhiInReader.getVariableAt(index));
        electron->setDEtaIn(dEtaInReader.getVariableAt(index));
        electron->setHadOverEm(hadOverEmReader.getVariableAt(index));
//        electron->setRobustLooseID(robustLooseIDReader.getVariableAt(index) == 1);
//        electron->setRobustTightID(robustTightIDReader.getVariableAt(index) == 1);
        electron->setDistToNextTrack(dist.getVariableAt(index));
        electron->setDCotThetaToNextTrack(dCotTheta.getVariableAt(index));

        electron->setSharedFractionInnerHits(sharedFractionInnerHits.getVariableAt(index));
        electron->setClosestTrackID(trackIDReader.getIntVariableAt(index));
        float trackPhi = track_phi.getVariableAt(index);
        float trackEta = track_eta.getVariableAt(index);
        float trackPt = track_pt.getVariableAt(index);
        float trackTheta = track_theta.getVariableAt(index);
        float trackCharge = track_charge.getIntVariableAt(index);
        TrackPointer track = TrackPointer(new Track(trackPhi, trackEta, trackPt, trackTheta));
        track->setCharge(trackCharge);
        if(algorithm == ElectronAlgorithm::Calo)
            track->setD0(electron->d0_wrtBeamSpot());
        else
            track->setD0(electron->d0());

        if(algorithm == ElectronAlgorithm::ParticleFlow){
            electron->setPFGammaIsolation(PFGammaIsolationReader.getVariableAt(index));
            electron->setPFChargedHadronIsolation(PFChargedHadronIsolationReader.getVariableAt(index));
            electron->setPFNeutralHadronIsolation(PFNeutralHadronIsolationReader.getVariableAt(index));
        }
        electron->setGSFTrack(track);
        electrons.push_back(electron);
    }
}

void ElectronReader::initialise() {
//    numberOfElectronsReader.initialise();
    energyReader.initialise();
    pxReader.initialise();
    pyReader.initialise();
    pzReader.initialise();
    chargeReader.initialise();
    superClusterEtaReader.initialise();

    if(d0_BS_Reader.doesVariableExist() && algorithm == ElectronAlgorithm::Calo)
        d0_BS_Reader.initialise();
    d0_PV_Reader.initialise();
    numberOfInnerLayerMissingHitsReader.initialise();

    ecalIsolationReader.initialise();
    hcalIsolationReader.initialise();
    trackerIsolationReader.initialise();

//    robustLooseIDReader.initialise();
//    robustTightIDReader.initialise();
    sigmaIEtaIEtaReader.initialise();
    dPhiInReader.initialise();
    dEtaInReader.initialise();
    hadOverEmReader.initialise();

    sharedFractionInnerHits.initialise();
    trackIDReader.initialise();
    track_phi.initialise();
    track_eta.initialise();
    track_pt.initialise();
    track_theta.initialise();
    track_charge.initialise();
    vertex_dist_z.initialise();
    dist.initialise();
    dCotTheta.initialise();
    if(algorithm == ElectronAlgorithm::ParticleFlow){
        PFGammaIsolationReader.initialise();
        PFChargedHadronIsolationReader.initialise();
        PFNeutralHadronIsolationReader.initialise();
    }
}

}



//***********************************************************************
//***** src/OSUAnalysis/Tools/src/Readers/GenParticleReader.cpp
//***********************************************************************


/*
 * GenParticleReader.cpp
 *
 *  Created on: Feb 23, 2011
 *      Author: phzss
 */

#include "../../interface/Readers/GenParticleReader.h"
namespace BAT {

GenParticleReader::GenParticleReader() :
    energyReader(),
  pxReader(),
  pyReader(),
  pzReader(),
  pdgIdReader(),
  statusReader(),
  motherIndexReader() {

}

GenParticleReader::GenParticleReader(TChainPointer input) :
    energyReader(input, "GenParticle.Energy"),
    pxReader(input, "GenParticle.Px"),
    pyReader(input, "GenParticle.Py"),
    pzReader(input, "GenParticle.Pz"),
    pdgIdReader(input, "GenParticle.PdgId"),
    statusReader(input, "GenParticle.Status"),
    motherIndexReader(input, "GenParticle.MotherIndex") {

}


GenParticleReader::~GenParticleReader() {
}

const MCParticleCollection& GenParticleReader::getGenParticles() {
    if (genParticles.empty() == false)
        genParticles.clear();
    readGenParticles();
    return genParticles;
}

void GenParticleReader::readGenParticles() {
    for (unsigned int index = 0; index < pxReader.size(); index++) {
        float energy = energyReader.getVariableAt(index);
        float px = pxReader.getVariableAt(index);
        float py = pyReader.getVariableAt(index);
        float pz = pzReader.getVariableAt(index);


        int pdgId = pdgIdReader.getIntVariableAt(index);
        int status = statusReader.getIntVariableAt(index);
        int motherIndex = motherIndexReader.getIntVariableAt(index);

        MCParticlePointer genParticle(new MCParticle(energy, px, py, pz));
        genParticle->setPdgId(pdgId);
        genParticle->setStatus(status);
        genParticle->setMotherIndex(motherIndex);

        genParticles.push_back(genParticle);
    }
}


void GenParticleReader::initialise() {
    energyReader.initialiseBlindly();
  pxReader.initialiseBlindly();
    pyReader.initialiseBlindly();
    pzReader.initialiseBlindly();

    pdgIdReader.initialiseBlindly();
    statusReader.initialiseBlindly();
    motherIndexReader.initialiseBlindly();
}

}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/Readers/TrackReader.cpp
//***********************************************************************


/*
 * TrackReader.cpp
 *
 *  Created on: 20 Sep 2010
 *      Author: kreczko
 */

#include "../../interface/Readers/TrackReader.h"
namespace BAT {

TrackReader::TrackReader() :
    phiReader(),
    etaReader(),
    ptReader(),
    thetaReader(),
    chargeReader(),
    d0Reader(),
    highPurityReader() {

}

TrackReader::TrackReader(TChainPointer input) :
    phiReader(input, "Track.Phi"),
    etaReader(input, "Track.Eta"),
    ptReader(input, "Track.Pt"),
    thetaReader(input, "Track.Theta"),
    chargeReader(input, "Track.Charge"),
    d0Reader(input, "Track.D0"),
    highPurityReader(input, "Track.isHighPurity") {

}

TrackReader::~TrackReader() {
}

const TrackCollection& TrackReader::getTracks() {
    if (tracks.empty() == false)
        tracks.clear();
    readTracks();
    return tracks;
}

void TrackReader::readTracks() {
    for (unsigned int index = 0; index < phiReader.size(); index++) {
        float phi = phiReader.getVariableAt(index);
        float eta = etaReader.getVariableAt(index);
        float pt = ptReader.getVariableAt(index);
        float theta = thetaReader.getVariableAt(index);
        TrackPointer track(new Track(phi, eta, pt, theta));
        track->setCharge(chargeReader.getIntVariableAt(index));
        track->setD0(d0Reader.getVariableAt(index));
        track ->setHighPurity(highPurityReader.getBoolVariableAt(index) > 0);

        tracks.push_back(track);
    }
}

void TrackReader::initialise() {
    phiReader.initialise();
    etaReader.initialise();
    ptReader.initialise();
    thetaReader.initialise();
    chargeReader.initialise();
    d0Reader.initialise();
    highPurityReader.initialise();
}

}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/Readers/JetReader.cpp
//***********************************************************************


/*
 * JetReader.cpp
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#include "../../interface/Readers/JetReader.h"

namespace BAT {

JetReader::JetReader() :
    energyReader(),
    pxReader(),
    pyReader(),
    pzReader(),
    massReader(),
    chargeReader(),
    emfReader(),
    n90HitsReader(),
    fHPDReader(),
    NODReader(),
    CEFReader(),
    NHFReader(),
    NEFReader(),
    CHFReader(),
    NCHReader(),
    btagSimpleSecondaryVertexReader(),
    btagTrackCountingHighPurityReader(),
    btagTrackCountingHighEfficiencyReader(),
//    genEnergyReader(),
//    genPxReader(),
//    genPyReader(),
//    genPzReader(),
//    genMassReader(),
//    genChargeReader(),
//    genEmfReader(),
    jets(),
//    genJets(),
    usedAlgorithm(JetAlgorithm::Calo_AntiKT_Cone05) {

}
JetReader::JetReader(TChainPointer input, JetAlgorithm::value algo) :
    energyReader(input, JetAlgorithm::prefixes.at(algo) + ".Energy"),
    pxReader(input, JetAlgorithm::prefixes.at(algo) + ".Px"),
    pyReader(input, JetAlgorithm::prefixes.at(algo) + ".Py"),
    pzReader(input, JetAlgorithm::prefixes.at(algo) + ".Pz"),
    massReader(input, JetAlgorithm::prefixes.at(algo) + ".Mass"),
    chargeReader(input, JetAlgorithm::prefixes.at(algo) + ".Charge"),
    emfReader(input, JetAlgorithm::prefixes.at(algo) + ".EMF"),
    n90HitsReader(input, JetAlgorithm::prefixes.at(algo) + ".n90Hits"),
    fHPDReader(input, JetAlgorithm::prefixes.at(algo) + ".fHPD"),
    NODReader(input, JetAlgorithm::prefixes.at(algo) + ".NConstituents"),
    CEFReader(input, JetAlgorithm::prefixes.at(algo) + ".ChargedEmEnergyFraction"),
    NHFReader(input, JetAlgorithm::prefixes.at(algo) + ".NeutralHadronEnergyFraction"),
    NEFReader(input, JetAlgorithm::prefixes.at(algo) + ".NeutralEmEnergyFraction"),
    CHFReader(input, JetAlgorithm::prefixes.at(algo) + ".ChargedHadronEnergyFraction"),
    NCHReader(input, JetAlgorithm::prefixes.at(algo) + ".ChargedMultiplicity"),
    btagSimpleSecondaryVertexReader(input, JetAlgorithm::prefixes.at(algo) + ".SimpleSecondaryVertexHighEffBTag"),
    btagTrackCountingHighPurityReader(input, JetAlgorithm::prefixes.at(algo) + ".TrackCountingHighPurBTag"),
    btagTrackCountingHighEfficiencyReader(input, JetAlgorithm::prefixes.at(algo) + ".TrackCountingHighEffBTag"),
//    genEnergyReader(input, "GenJet.Energy"),
//    genPxReader(input, "GenJet.Px"),
//    genPyReader(input, "GenJet.Py"),
//    genPzReader(input, "GenJet.Pz"),
//    genMassReader(input, "GenJet.Mass"),
//    genChargeReader(input, "GenJet.Charge"),
//    genEmfReader(input, "GenJet.EMF"),
    jets(),
//    genJets(),
    usedAlgorithm(algo) {

}
JetReader::~JetReader() {
}

const JetCollection& JetReader::getJets() {
  if (jets.empty() == false)
    jets.clear();
  readJets();
  return jets;
}

//const JetCollection& JetReader::getGenJets() {
//  if (genJets.empty() == false)
//    genJets.clear();
//  readGenJets();
//  return genJets;
//}

void JetReader::readJets() {
  for (unsigned int jetIndex = 0; jetIndex < energyReader.size(); jetIndex++) {
    float energy = energyReader.getVariableAt(jetIndex);
    float px = pxReader.getVariableAt(jetIndex);
    float py = pyReader.getVariableAt(jetIndex);
    float pz = pzReader.getVariableAt(jetIndex);
    JetPointer jet(new Jet(energy, px, py, pz));
    jet->setUsedAlgorithm(usedAlgorithm);
    jet->setMass(massReader.getVariableAt(jetIndex));
    jet->setCharge(chargeReader.getVariableAt(jetIndex));

    if (usedAlgorithm == JetAlgorithm::Calo_AntiKT_Cone05 || usedAlgorithm
        == JetAlgorithm::JPT_AntiKt_ConeDR05) {
      jet->setEMF(emfReader.getVariableAt(jetIndex));
      jet->setN90Hits(n90HitsReader.getIntVariableAt(jetIndex));
      jet->setFHPD(fHPDReader.getVariableAt(jetIndex));
    } else {
      jet->setEMF(0);
      jet->setN90Hits(0);
      jet->setFHPD(0);
    }

    jet->setDiscriminatorForBtagType(
        btagSimpleSecondaryVertexReader.getVariableAt(jetIndex),
        BtagAlgorithm::SimpleSecondaryVertexHighEffBTag);
    jet->setDiscriminatorForBtagType(
        btagTrackCountingHighPurityReader.getVariableAt(jetIndex),
        BtagAlgorithm::TrackCountingHighPurBTag);
    jet->setDiscriminatorForBtagType(
        btagTrackCountingHighEfficiencyReader.getVariableAt(jetIndex),
        BtagAlgorithm::TrackCountingHighEffBTag);

    if (usedAlgorithm == JetAlgorithm::ParticleFlow || usedAlgorithm
        == JetAlgorithm::PF2PAT) {
      jet->setNOD(NODReader.getIntVariableAt(jetIndex));
      jet->setCEF(CEFReader.getVariableAt(jetIndex));
      jet->setNHF(NHFReader.getVariableAt(jetIndex));
      jet->setNEF(NEFReader.getVariableAt(jetIndex));
      jet->setCHF(CHFReader.getVariableAt(jetIndex));
      jet->setNCH(NCHReader.getIntVariableAt(jetIndex));
    }
    jets.push_back(jet);
  }
}

//void JetReader::readGenJets() {
//  for (unsigned int jetIndex = 0; jetIndex < genEnergyReader.size(); jetIndex++) {
//    float energy = genEnergyReader.getVariableAt(jetIndex);
//    float px = genPxReader.getVariableAt(jetIndex);
//    float py = genPyReader.getVariableAt(jetIndex);
//    float pz = genPzReader.getVariableAt(jetIndex);
//    JetPointer jet(new Jet(energy, px, py, pz));
//
//    jet->setUsedAlgorithm(usedAlgorithm);
//    jet->setMass(genMassReader.getVariableAt(jetIndex));
//    jet->setCharge(genChargeReader.getVariableAt(jetIndex));
//    jet->setEMF(genEmfReader.getVariableAt(jetIndex));
//
//    genJets.push_back(jet);
//  }
//}

void JetReader::initialise() {
  energyReader.initialise();
  pxReader.initialise();
  pyReader.initialise();
  pzReader.initialise();
  massReader.initialise();
  chargeReader.initialise();
  if (usedAlgorithm == JetAlgorithm::Calo_AntiKT_Cone05 || usedAlgorithm
      == JetAlgorithm::JPT_AntiKt_ConeDR05) {
    emfReader.initialise();
    n90HitsReader.initialise();
    fHPDReader.initialise();
  }
  btagSimpleSecondaryVertexReader.initialise();
  btagTrackCountingHighPurityReader.initialise();
  btagTrackCountingHighEfficiencyReader.initialise();
  if (usedAlgorithm == JetAlgorithm::ParticleFlow || usedAlgorithm
      == JetAlgorithm::PF2PAT) {
    NODReader.initialise();
    CEFReader.initialise();
    NHFReader.initialise();
    NEFReader.initialise();
    CHFReader.initialise();
    NCHReader.initialise();
  }

//  genEnergyReader.initialiseBlindly();
//  genPxReader.initialiseBlindly();
//  genPyReader.initialiseBlindly();
//  genPzReader.initialiseBlindly();
//  genMassReader.initialiseBlindly();
//  genEmfReader.initialiseBlindly();
//  genChargeReader.initialiseBlindly();
}
}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/Readers/NTupleEventReader.cpp
//***********************************************************************


/*
 * NTupleEventReader.cpp
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#include "../../interface/Readers/NTupleEventReader.h"
#include "TFile.h"
#include "TChainElement.h"
#include <iostream>
#include <boost/shared_ptr.hpp>
using namespace std;
namespace BAT {

const char * NTupleEventReader::EVENT_CHAIN = "rootTupleTree/tree";

JetAlgorithm::value NTupleEventReader::jetAlgorithm = JetAlgorithm::Calo_AntiKT_Cone05;
ElectronAlgorithm::value NTupleEventReader::electronAlgorithm = ElectronAlgorithm::Calo;
METAlgorithm::value NTupleEventReader::metAlgorithm = METAlgorithm::Calo;
MuonAlgorithm::value NTupleEventReader::muonAlgorithm = MuonAlgorithm::Default;
bool NTupleEventReader::loadTracks = false;

NTupleEventReader::NTupleEventReader() :
    processedEvents(0),
    maximalNumberOfEvents(999999999),
    currentEventEntry(0),
    numberOfFiles(0),
    input(new TChain(NTupleEventReader::EVENT_CHAIN)),
    hltReader(new VariableReader<MultiIntPointer>(input, "Trigger.HLTResults")),
    vertexReader(new VertexReader(input)),
    trackReader(new TrackReader(input)),
    electronReader(new ElectronReader(input, NTupleEventReader::electronAlgorithm)),
    genParticleReader(new GenParticleReader(input)),
    jetReader(new JetReader(input, NTupleEventReader::jetAlgorithm)),
    genJetReader(new GenJetReader(input)),
    muonReader(new MuonReader(input, NTupleEventReader::muonAlgorithm)),
    metReader(new METReader(input, NTupleEventReader::metAlgorithm)),
    runNumberReader(new VariableReader<unsigned int> (input, "Event.Run")),
    eventNumberReader(new VariableReader<unsigned int> (input, "Event.Number")),
    lumiBlockReader(new VariableReader<unsigned int> (input, "Event.LumiSection")),
//    beamScrapingReader(new VariableReader<bool> (input, "isBeamScraping")),
    areReadersSet(false),
    areDatatypesKnown(false),
    currentEvent(),
    seenDataTypes() {
}

NTupleEventReader::~NTupleEventReader() {
}

void NTupleEventReader::addInputFile(const char * fileName) {
    unsigned long filesAdded = input->Add(fileName, -1);//-1 == number of events is not read!
    if (filesAdded <= 0)
        throw NoFileFoundException("No file found in '" + TString(fileName) + "'");
    numberOfFiles += filesAdded;
}

void NTupleEventReader::addInputFileWithoutCheck(const char * fileName) {
    numberOfFiles += input->Add(fileName);
}

const Event& NTupleEventReader::getNextEvent() {
    currentEvent = Event();
    selectNextNtupleEvent();

    boost::shared_ptr<std::vector<int> > triggers(new std::vector<int>());

    for(unsigned int i = 0; i < hltReader->size(); i++){
        triggers->push_back(hltReader->getIntVariableAt(i));
    }

    currentEvent.setDataType(getDataType(getCurrentFile()));
    currentEvent.setHLTs(triggers);
    currentEvent.setVertices(vertexReader->getVertices());

    if(NTupleEventReader::loadTracks)
        currentEvent.setTracks(trackReader->getTracks());
    currentEvent.setElectrons(electronReader->getElectrons());

    if(!currentEvent.isRealData()) {
      currentEvent.setGenParticles(genParticleReader->getGenParticles());
      currentEvent.setGenJets(genJetReader->getGenJets());
    }

    currentEvent.setJets(jetReader->getJets());
    currentEvent.setMuons(muonReader->getMuons());
    currentEvent.setMET(metReader->getMET());
    currentEvent.setRunNumber(runNumberReader->getVariable());
    currentEvent.setEventNumber(eventNumberReader->getVariable());
    currentEvent.setLocalEventNumber(currentEventEntry);
    currentEvent.setLumiBlock(lumiBlockReader->getVariable());
    currentEvent.setBeamScrapingVeto(false);

    return currentEvent;
}

void NTupleEventReader::selectNextNtupleEvent() {
    if (hasNextEvent()) {
        initiateReadersIfNotSet();
        input->GetEntry(currentEventEntry);
        currentEventEntry++;
        processedEvents++;
    }
}

bool NTupleEventReader::hasNextEvent() {
    if (numberOfFiles == 0)
        throw NoFileFoundException("No input file found!");
    bool hasNextInNTuple = input->LoadTree(currentEventEntry) >= 0;
    bool isWithinEventRange = currentEventEntry < maximalNumberOfEvents;
    return hasNextInNTuple && isWithinEventRange;
}

void NTupleEventReader::initiateReadersIfNotSet() {
    if (areReadersSet == false) {
        input->SetBranchStatus("*", 0);
        hltReader->initialise();
        vertexReader->initialise();
        if(NTupleEventReader::loadTracks)
            trackReader->initialise();
        electronReader->initialise();
        genParticleReader->initialise();
        jetReader->initialise();
        genJetReader->initialise();
        muonReader->initialise();
        metReader->initialise();
        runNumberReader->initialise();
        eventNumberReader->initialise();
        lumiBlockReader->initialise();
//        beamScrapingReader->initialise();
        areReadersSet = true;
    }

}

DataType::value NTupleEventReader::getDataType(const std::string filename) {
    DataType::value filetype = DataType::DATA;

    for (unsigned int index = 0; index < DataType::names.size(); ++index) {
        const std::string searchString(DataType::names.at(index));

        if (filename.find(searchString) != std::string::npos) {
            filetype = (DataType::value) index;
        }
    }
    return filetype;
}

unsigned long NTupleEventReader::getNumberOfProccessedEvents() const {
    return processedEvents;
}

unsigned long NTupleEventReader::getCurrentLocalEventNumber() const {
    return currentEventEntry;
}

void NTupleEventReader::skipNumberOfEvents(unsigned long skipNextNEvents) {
    currentEventEntry += skipNextNEvents;
}

void NTupleEventReader::setMaximumNumberOfEvents(unsigned long maxNumberOfEvents) {
    maximalNumberOfEvents = maxNumberOfEvents;
}

const boost::array<bool, DataType::NUMBER_OF_DATA_TYPES>& NTupleEventReader::getSeenDatatypes() {
    if (areDatatypesKnown == false) {
        readDataTypes();
        areDatatypesKnown = true;
    }
    return seenDataTypes;
}

void NTupleEventReader::readDataTypes() {
    TIter nextFile(input->GetListOfFiles());
    TChainElement* file = 0;
    while ((file = (TChainElement*) nextFile()) != 0) {
        string fileName = file->GetTitle();
        DataType::value type = getDataType(fileName);
        seenDataTypes.at(type) = true;
    }
}

const char* NTupleEventReader::getCurrentFile() const {
  if (input->GetCurrentFile() == 0)
    throw NoFileFoundException("Tried to access non-existent file.");
    return input->GetCurrentFile()->GetName();
}
}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/Readers/VertexReader.cpp
//***********************************************************************


/*
 * PrimaryVertexReader.cpp
 *
 *  Created on: 25 Jul 2010
 *      Author: kreczko
 */

#include "../../interface/Readers/VertexReader.h"

namespace BAT {

VertexReader::VertexReader() :
  ndofReader(),
  zReader(),
  rhoReader(),
  isfakeReader(),
  vertices() {

}

VertexReader::VertexReader(TChainPointer input) :
  ndofReader(input, "Vertex.NDF"),
  zReader(input, "Vertex.Z"),
  rhoReader(input, "Vertex.Rho"),
  isfakeReader(input, "Vertex.IsFake"),
  vertices() {

}

void VertexReader::initialise() {
    ndofReader.initialise();
    zReader.initialise();
    rhoReader.initialise();
    isfakeReader.initialise();
}

const VertexCollection& VertexReader::getVertices() {
    if (vertices.empty() == false)
        vertices.clear();
    readVertices();
    return vertices;
}

void VertexReader::readVertices() {
    for (unsigned int index = 0; index < ndofReader.size(); index++) {
        VertexPointer vertex(new Vertex());
        vertex->setDegreesOfFreedom(ndofReader.getVariableAt(0));
        vertex->setFake(isfakeReader.getBoolVariableAt(0));
        vertex->setRho(rhoReader.getVariableAt(0));
        vertex->setZPosition(zReader.getVariableAt(0));
        vertices.push_back(vertex);
    }
}

VertexReader::~VertexReader() {
}

}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/Readers/MuonReader.cpp
//***********************************************************************


/*
 * MuonReader.cpp
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#include "../../interface/Readers/MuonReader.h"

namespace BAT {

MuonReader::MuonReader() :
//  numberOfMuonsReader(),
  energyReader(),
  pxReader(),
  pyReader(),
  pzReader(),
  ecalIsolationReader(),
  hcalIsolationReader(),
  trackerIsolationReader(),
  isGlobalReader() {

}

MuonReader::MuonReader(TChainPointer input, MuonAlgorithm::value algo) :
  energyReader(input, MuonAlgorithm::prefixes.at(algo) + ".Energy"),
  pxReader(input, MuonAlgorithm::prefixes.at(algo) + ".Px"),
  pyReader(input, MuonAlgorithm::prefixes.at(algo) + ".Py"),
  pzReader(input, MuonAlgorithm::prefixes.at(algo) + ".Pz"),
  ecalIsolationReader(input, MuonAlgorithm::prefixes.at(algo) + ".EcalIso03"),
  hcalIsolationReader(input, MuonAlgorithm::prefixes.at(algo) + ".HcalIso03"),
  trackerIsolationReader(input, MuonAlgorithm::prefixes.at(algo) + ".TrkIso03"),
  isGlobalReader(input, MuonAlgorithm::prefixes.at(algo) + ".isGoodGlobalMuon") {

}

void MuonReader::initialise() {
    energyReader.initialise();
    pxReader.initialise();
    pyReader.initialise();
    pzReader.initialise();

    ecalIsolationReader.initialise();
    hcalIsolationReader.initialise();
    trackerIsolationReader.initialise();

    isGlobalReader.initialise();
}

const MuonCollection& MuonReader::getMuons() {
    if (muons.empty() == false)
        muons.clear();
    readMuons();
    return muons;
}

void MuonReader::readMuons() {
    for (unsigned int index = 0; index < energyReader.size(); index++) {
        float energy = energyReader.getVariableAt(index);
        float px = pxReader.getVariableAt(index);
        float py = pyReader.getVariableAt(index);
        float pz = pzReader.getVariableAt(index);
        MuonPointer muon(new Muon(energy, px, py, pz));
        muon->setEcalIsolation(ecalIsolationReader.getVariableAt(index));
        muon->setHcalIsolation(hcalIsolationReader.getVariableAt(index));
        muon->setTrackerIsolation(trackerIsolationReader.getVariableAt(index));
        muon->makeGlobal(isGlobalReader.getBoolVariableAt(index));
        muons.push_back(muon);
    }
}
MuonReader::~MuonReader() {
}

}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/Readers/VariableReader.cpp
//***********************************************************************


/*
 * VariableReader.cpp
 *
 *  Created on: 24 Aug 2010
 *      Author: kreczko
 */

#include "../../interface/Readers/VariableReader.h"

namespace BAT {

template<>
VariableReader<MultiFloatPointer>::~VariableReader(){
    delete variable;
}

template<>
unsigned int VariableReader<MultiFloatPointer>::size() const{
    throwExceptionIfNotItitialised();
    return variable->size();
}

template<>
unsigned int VariableReader<MultiDoublePointer>::size() const{
    throwExceptionIfNotItitialised();
    return variable->size();
}

template<>
unsigned int VariableReader<MultiIntPointer>::size() const{
    throwExceptionIfNotItitialised();
    return variable->size();
}

template<>
unsigned int VariableReader<MultiBoolPointer>::size() const{
    throwExceptionIfNotItitialised();
    return variable->size();
}

template<>
double VariableReader<MultiFloatPointer>::getVariableAt(unsigned int index) const{
    throwExceptionIfNotItitialised();
    return variable->at(index);
}

template<>
double VariableReader<MultiDoublePointer>::getVariableAt(unsigned int index) const{
    throwExceptionIfNotItitialised();
    return variable->at(index);
}

template<>
int VariableReader<MultiIntPointer>::getIntVariableAt(unsigned int index) const{
    throwExceptionIfNotItitialised();
    return variable->at(index);
}

template<>
unsigned int VariableReader<MultiIntPointer>::getUIntVariableAt(unsigned int index) const{
    throwExceptionIfNotItitialised();
    return variable->at(index);
}
template<>
bool VariableReader<MultiBoolPointer>::getBoolVariableAt(unsigned int index) const{
    throwExceptionIfNotItitialised();
    return variable->at(index);
}
}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/Readers/METReader.cpp
//***********************************************************************


/*
 * METReader.cpp
 *
 *  Created on: 4 Aug 2010
 *      Author: kreczko
 */

#include "../../interface/Readers/METReader.h"

namespace BAT {
//const std::string METReader::algorithmPrefixes[METAlgorithm::NUMBER_OF_METALGORITHMS] = {
//        "mets",
//        "tcmets",
//        "PFMets" };

METReader::METReader() :
    exReader(), eyReader(), met() {

}

METReader::METReader(TChainPointer input, METAlgorithm::value algo) :
    exReader(input, METAlgorithm::prefixes.at(algo) + ".Ex"),
    eyReader(input, METAlgorithm::prefixes.at(algo) + ".Ey") {

}

METReader::~METReader() {
}

void METReader::initialise() {
    exReader.initialise();
    eyReader.initialise();
}

const METPointer METReader::getMET() {
    readMET();
    return met;
}

void METReader::readMET() {
    met = METPointer(new MET(exReader.getVariableAt(0), eyReader.getVariableAt(0)));
}
}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/Readers/GenJetReader.cpp
//***********************************************************************


/*
 * JetReader.cpp
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#include "../../interface/Readers/GenJetReader.h"

namespace BAT {

GenJetReader::GenJetReader() :
    genEnergyReader(),
    genPxReader(),
    genPyReader(),
    genPzReader(),
    genMassReader(),
    genChargeReader(),
    genEmfReader(),
    genJets() {

}
GenJetReader::GenJetReader(TChainPointer input) :
    genEnergyReader(input, "GenJet.Energy"),
    genPxReader(input, "GenJet.Px"),
    genPyReader(input, "GenJet.Py"),
    genPzReader(input, "GenJet.Pz"),
    genMassReader(input, "GenJet.Mass"),
    genChargeReader(input, "GenJet.Charge"),
    genEmfReader(input, "GenJet.EMF"),
    genJets() {

}
GenJetReader::~GenJetReader() {
}

const JetCollection& GenJetReader::getGenJets() {
  if (genJets.empty() == false)
    genJets.clear();
  readGenJets();
  return genJets;
}

void GenJetReader::readGenJets() {
  for (unsigned int jetIndex = 0; jetIndex < genEnergyReader.size(); jetIndex++) {
    float energy = genEnergyReader.getVariableAt(jetIndex);
    float px = genPxReader.getVariableAt(jetIndex);
    float py = genPyReader.getVariableAt(jetIndex);
    float pz = genPzReader.getVariableAt(jetIndex);
    JetPointer jet(new Jet(energy, px, py, pz));

    jet->setUsedAlgorithm(JetAlgorithm::Calo_AntiKT_Cone05);
    jet->setMass(genMassReader.getVariableAt(jetIndex));
    jet->setCharge(genChargeReader.getVariableAt(jetIndex));
    jet->setEMF(genEmfReader.getVariableAt(jetIndex));

    genJets.push_back(jet);
  }
}

void GenJetReader::initialise() {
  genEnergyReader.initialiseBlindly();
  genPxReader.initialiseBlindly();
  genPyReader.initialiseBlindly();
  genPzReader.initialiseBlindly();
  genMassReader.initialiseBlindly();
  genEmfReader.initialiseBlindly();
  genChargeReader.initialiseBlindly();
}
}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/TtbarHypothesis.cpp
//***********************************************************************


/*
 * TtbarHypothesis.cpp
 *
 *  Created on: Dec 4, 2010
 *      Author: lkreczko
 */

#include "../interface/TtbarHypothesis.h"

namespace BAT {

TtbarHypothesis::TtbarHypothesis() :
  totalChi2(99999.), 
  leptonicChi2(99999.), 
  hadronicChi2(99999.), 
  globalChi2(99999.), 
  hadronicTop(), 
  leptonicTop(),
  leptonicW(), 
  hadronicW(), 
  resonance(), 
  neutrinoFromW(), 
  leptonicBjet(), 
  hadronicBJet(), 
  jet1FromW(),
  jet2FromW(), 
  electronFromW(), 
  met() {

}

TtbarHypothesis::~TtbarHypothesis() {

}

bool TtbarHypothesis::operator <(const TtbarHypothesis& hyp) const {
  return totalChi2 < hyp.totalChi2;
}

bool TtbarHypothesis::operator ==(const TtbarHypothesis& hyp) const {
  return totalChi2 == hyp.totalChi2;
}

} // namespace BAT


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/Taggers/ConversionTagger.cpp
//***********************************************************************


/*
 * ConversionTagger.cpp
 *
 *  Created on: Jun 30, 2010
 *      Author: lkreczko
 */

#include "../../interface/Taggers/ConversionTagger.h"
#include <iostream>

using namespace std;
namespace BAT {

ConversionTagger::ConversionTagger() :
    electron(), tracks(), partnerTrack(), electronTrack(), minFracSharedHits(99999), distance(-9999), deltaCot(-9999), electronTrackID(
            -999) {

}

ConversionTagger::~ConversionTagger() {
}

bool ConversionTagger::isFromConversion(double maxAbsDistance, double maxAbsDeltaCot) {
    return fabs(distance) < maxAbsDistance && fabs(deltaCot) < maxAbsDeltaCot;
}

void ConversionTagger::calculateConversionVariables(const ElectronPointer electron, const TrackCollection tracks,
        const double bfieldAtOrigin = 3.8, const double minFracSharedHits = 0.45) {
    this->electron = electron;
    this->tracks = tracks;
    this->minFracSharedHits = minFracSharedHits;
    electronTrackID = -999;
    distance = -9999;
    deltaCot = -9999;

    electronTrack = getElectronTrack();

    findClosestTrack();
    if (partnerTrack.get() != 0 && electronTrack != 0) {
        distance = partnerTrack->distance(electronTrack);
        deltaCot = partnerTrack->deltaCotTheta(electronTrack);
    }
}

const TrackPointer ConversionTagger::getElectronTrack() {
    if (electron->closestCTFTrackID() >= 0 && electron->shFracInnerLayer() > minFracSharedHits) {
        electronTrackID = electron->closestCTFTrackID();
        return tracks.at(electronTrackID);
    }

    else
        return electron->GSFTrack();
}

void ConversionTagger::findClosestTrack() {
    if(electronTrack.get() == 0)
        return;

    double mindDcot = 99999.;
    for (unsigned int trackIndex = 0; trackIndex < tracks.size(); ++trackIndex) {
        if (abs(electronTrackID) - trackIndex == 0)
            continue;

        const TrackPointer trackCandidate = tracks.at(trackIndex);
        if (electronTrack->isWithinDeltaR(0.5, trackCandidate) == false)
            continue;

        if (electronTrack->charge() + trackCandidate->charge() != 0)
            continue;

        double dcot = trackCandidate->deltaCotTheta(electronTrack);
        if (dcot < mindDcot) {
            mindDcot = dcot;
            partnerTrack = trackCandidate;
        }
    }
}
}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/ReconstructionRules/BasicRule.cpp
//***********************************************************************


/*
 * BasicRule.cpp
 *
 *  Created on: 15 Apr 2011
 *      Author: kreczko
 */

#include "../../interface/ReconstructionRules/BasicRule.h"
namespace BAT {
BasicRule::BasicRule() {

}

BasicRule::~BasicRule() {
}

double BasicRule::softGlobalCondition(const TtbarHypothesisPointer hypo) const {
    return 0;
}

bool BasicRule::hardGlobalCondition(const TtbarHypothesisPointer hypo) const {
    return true;
}

double BasicRule::softHadronicBJetCondition(const JetPointer jet) const {
    return 0;
}

bool BasicRule::hardHadronicBJetCondition(const JetPointer jet) const {
    return 0;
}

double BasicRule::softLeptonicBJetCondition(const JetPointer jet) const {
    return 0;
}

bool BasicRule::hardLeptonicBJetCondition(const JetPointer jet) const {
    return 0;
}

double BasicRule::softHadronicJetFromWCondition(const JetPointer jet) const {
    return 0;
}
bool BasicRule::hardHadronicJetFromWCondition(const JetPointer jet) const {
    return true;
}
}


//***********************************************************************
//***** src/OSUAnalysis/Tools/src/TopPairEventCandidate.cpp
//***********************************************************************


/*
 * TopPairEventCandidate.cpp
 *
 *  Created on: 9 Jul 2010
 *      Author: kreczko
 */

#include "../interface/TopPairEventCandidate.h"
#include <iostream>
#include <iomanip>
using namespace std;

namespace BAT {

double const TopPairEventCandidate::matched_angle = 0.945666;
double const TopPairEventCandidate::matched_angle_sigma = 0.311091;
double const TopPairEventCandidate::matched_leptonic_top_mass = 169.0;
double const TopPairEventCandidate::matched_leptonic_top_mass_sigma = 16.3;
double const TopPairEventCandidate::matched_hadronic_W_mass = 83.;
double const TopPairEventCandidate::matched_hadronic_W_mass_sigma = 10.8995;
double const TopPairEventCandidate::matched_hadronic_top_mass = 174.7;
double const TopPairEventCandidate::matched_hadronic_top_mass_sigma = 14.6;
double const TopPairEventCandidate::matched_ptratio = 0.18552;
double const TopPairEventCandidate::matched_ptratio_sigma = 0.401973;
double const TopPairEventCandidate::matched_pt_ttbarSystem = 0.;
double const TopPairEventCandidate::matched_pt_ttbarSystem_sigma = 50.;
double const TopPairEventCandidate::matched_HTSystem = 1;
double const TopPairEventCandidate::matched_HTSystem_sigma = 0.1;
double const TopPairEventCandidate::W_mass = 80.389;

NeutrinoSelectionCriterion::value TopPairEventCandidate::usedNeutrinoSelection; // = NeutrinoSelectionCriterion::chi2;
TTbarReconstructionCriterion::value TopPairEventCandidate::usedTTbarReconstruction; // = TTbarReconstructionCriterion::TopMassDifference;


TopPairEventCandidate::TopPairEventCandidate() :
    Event(),
    electronFromW(),
    leptonicBJet(),
    hadronicBJet(),
    jet1FromW(),
    jet2FromW(),
    neutrino1(),
    neutrino2(),
    leptonicW1(),
    leptonicW2(),
    hadronicW(),
    leptonicTop1(),
    leptonicTop2(),
    hadronicTop(),
    selectedNeutrino(0),
    currentSelectedNeutrino(0),
    hadronicBIndex(0),
    leptonicBIndex(0),
    jet1FromWIndex(0),
    jet2FromWIndex(0),
    doneReconstruction(false),
    conversionTagger(new ConversionTagger()),
    doneConversionTagging(false),
    solutions(),
    compareSolutions(){
}

TopPairEventCandidate::TopPairEventCandidate(const Event& event) :
    Event(event),
    electronFromW(),
    leptonicBJet(),
    hadronicBJet(),
    jet1FromW(),
    jet2FromW(),
    neutrino1(),
    neutrino2(),
    leptonicW1(),
    leptonicW2(),
    hadronicW(),
    leptonicTop1(),
    leptonicTop2(),
    hadronicTop(),
    selectedNeutrino(0),
    currentSelectedNeutrino(0),
    hadronicBIndex(0),
    leptonicBIndex(0),
    jet1FromWIndex(0),
    jet2FromWIndex(0),
    doneReconstruction(false),
    conversionTagger(new ConversionTagger()),
    doneConversionTagging(false) {

}

TopPairEventCandidate::~TopPairEventCandidate() {
}

bool TopPairEventCandidate::passesScrapingFilter() const {
    if (tracks.size() > 10) {
        if (numberOfHighPurityTracks / (1.0 * tracks.size()) > 0.25)
            return true;
        else
            return false;
    } else
        return isBeamScraping == false;
}

bool TopPairEventCandidate::passesHighLevelTrigger() const {
    if (isRealData()) {
        if (runNumber < 140041)
            return HLT(HLTriggers::HLT_Ele10_LW_L1R);
        else if (runNumber >= 140041 && runNumber <= 143962)
            return HLT(HLTriggers::HLT_Ele15_SW_L1R);
        else if (runNumber > 143962 && runNumber <= 146427)
            return HLT(HLTriggers::HLT_Ele15_SW_CaloEleId_L1R);
        else if (runNumber > 146427 && runNumber <= 147116)
            return HLT(HLTriggers::HLT_Ele17_SW_CaloEleId_L1R);
        else if (runNumber > 147116 && runNumber <= 148818)
            return HLT(HLTriggers::HLT_Ele17_SW_TightEleId_L1R);
        else if (runNumber >= 148819 && runNumber < 149181)
            return HLT(HLTriggers::HLT_Ele22_SW_TighterEleId_L1R_v2);
        else if(runNumber >= 149181 && runNumber < 160000)
            return HLT(HLTriggers::HLT_Ele22_SW_TighterEleId_L1R_v3);
        else if(runNumber > 160000)
            return HLT(HLTriggers::HLT_Ele27_CaloIdVT_CaloIsoT_TrkIdT_TrkIsoT_v1) || HLT(
                    HLTriggers::HLT_Ele27_CaloIdVT_CaloIsoT_TrkIdT_TrkIsoT_v2) || HLT(
                    HLTriggers::HLT_Ele25_CaloIdVT_TrkIdT_CentralTriJet30_v1) || HLT(
                    HLTriggers::HLT_Ele25_CaloIdVT_TrkIdT_CentralTriJet30_v2);
        else
            return false;
    }
    else // do not use HLT for MC
        return true;
}

bool TopPairEventCandidate::hasOneGoodPrimaryVertex() const {
    return PrimaryVertex()->isGood();
}

bool TopPairEventCandidate::hasOnlyOneGoodIsolatedElectron() const {
    if(Event::usePFIsolation)
        return goodPFIsolatedElectrons.size() == 1;
    else
        return goodIsolatedElectrons.size() == 1;
}

bool TopPairEventCandidate::isolatedElectronDoesNotComeFromConversion() const {
    bool passConversion = false;
    if (Event::usePFIsolation) {
        if (goodPFIsolatedElectrons.size() > 0)
            passConversion = goodPFIsolatedElectrons.front()->isFromConversion() == false;
    } else {
        if (goodIsolatedElectrons.size() > 0)
            passConversion = goodIsolatedElectrons.front()->isFromConversion() == false;
    }

    return passConversion;
}

bool TopPairEventCandidate::isolatedElectronNotTaggedAsFromConversion() const {
    bool passConversion = false;
    ElectronPointer electron;
    if (Event::usePFIsolation) {
        if (goodPFIsolatedElectrons.size() > 0)
            electron = goodPFIsolatedElectrons.front();
    } else {
        if (goodIsolatedElectrons.size() > 0)
            electron = goodIsolatedElectrons.front();
    }
    if (electron != 0) {
        if (useCustomConversionTagger) {
            conversionTagger->calculateConversionVariables(electron, tracks, 3.8, 0.45);
            passConversion = conversionTagger->isFromConversion(0.02, 0.02) == false;
        } else {
            passConversion = electron->isTaggedAsConversion(0.02, 0.02) == false;
        }
    }

    return passConversion;
}

bool TopPairEventCandidate::hasNoIsolatedMuon() const {
    return goodIsolatedMuons.size() == 0;
}

bool TopPairEventCandidate::hasAtLeastOneGoodJet() const {
    return goodJets.size() >= 1;
}

bool TopPairEventCandidate::hasAtLeastTwoGoodJets() const {
    return goodJets.size() >= 2;
}

bool TopPairEventCandidate::hasAtLeastThreeGoodJets() const {
    return goodJets.size() >= 3;
}

bool TopPairEventCandidate::hasAtLeastFourGoodJets() const {
    return goodJets.size() >= 4;
}

bool TopPairEventCandidate::isNotAZBosonEvent() const {
    float invariantMass = 0;
    bool isZEvent = false;
    ElectronPointer isoElectron;

    if (Event::usePFIsolation && goodPFIsolatedElectrons.size() > 0)
        isoElectron = goodPFIsolatedElectrons.front();
    else if (goodIsolatedElectrons.size() > 0)
        isoElectron = goodIsolatedElectrons.front();

    if (isoElectron != NULL && allElectrons.size() > 1) {
        for (unsigned int index = 0; index < allElectrons.size(); ++index) {
            const ElectronPointer looseElectron = allElectrons.at(index);
            bool passLooseIso = false;

            if (Event::usePFIsolation)
                passLooseIso = looseElectron->isLoose() && looseElectron->pfIsolation() < 1.;
            else
                passLooseIso = looseElectron->isLoose() && looseElectron->relativeIsolation() < 1.;

            if (passLooseIso)
                invariantMass = isoElectron->invariantMass(looseElectron);
            else
                invariantMass = 0;

            bool passesLowerLimit = invariantMass > 76;
            bool passesUpperLimit = invariantMass < 106;
            if (passesLowerLimit && passesUpperLimit)
                isZEvent = true;
        }

    }


    return isZEvent == false;
}

bool TopPairEventCandidate::passesFullTTbarEPlusJetSelection() const {
    unsigned int newstep = (int) TTbarEPlusJetsSelection::NUMBER_OF_SELECTION_STEPS - 1;
    return passesSelectionStepUpTo((TTbarEPlusJetsSelection::Step) newstep);
}

bool TopPairEventCandidate::passesSelectionStepUpTo(enum TTbarEPlusJetsSelection::Step step) const {
    if (step == TTbarEPlusJetsSelection::FilterOutScraping)
        return passesSelectionStep(step);
    else {
        unsigned int newstep = (int) step - 1;
        return passesSelectionStep(step) && passesSelectionStepUpTo((TTbarEPlusJetsSelection::Step) newstep);
    }
}

bool TopPairEventCandidate::passesNMinus1(enum TTbarEPlusJetsSelection::Step omitted) const {
    bool passes(true);

    for (unsigned int cut = 0; cut < TTbarEPlusJetsSelection::NUMBER_OF_SELECTION_STEPS; ++cut) {
        if (cut == (unsigned int) omitted)
            continue;
        passes = passes && passesSelectionStep((TTbarEPlusJetsSelection::Step) cut);
    }
    return passes;
}

bool TopPairEventCandidate::passesSelectionStep(enum TTbarEPlusJetsSelection::Step step) const {
    switch (step) {
    case TTbarEPlusJetsSelection::FilterOutScraping:
        return passesScrapingFilter();
    case TTbarEPlusJetsSelection::HighLevelTrigger:
        return passesHighLevelTrigger();
    case TTbarEPlusJetsSelection::GoodPrimaryvertex:
        return hasOneGoodPrimaryVertex();
    case TTbarEPlusJetsSelection::OneIsolatedElectron:
        return hasOnlyOneGoodIsolatedElectron();
    case TTbarEPlusJetsSelection::ConversionRejection:
        return isolatedElectronDoesNotComeFromConversion();
    case TTbarEPlusJetsSelection::ConversionFinder:
        return isolatedElectronNotTaggedAsFromConversion();
    case TTbarEPlusJetsSelection::LooseMuonVeto:
        return hasNoIsolatedMuon();
    case TTbarEPlusJetsSelection::AtLeastOneGoodJets:
        return hasAtLeastOneGoodJet();
    case TTbarEPlusJetsSelection::AtLeastTwoGoodJets:
        return hasAtLeastTwoGoodJets();
    case TTbarEPlusJetsSelection::AtLeastThreeGoodJets:
        return hasAtLeastThreeGoodJets();
    case TTbarEPlusJetsSelection::AtLeastFourGoodJets:
        return hasAtLeastFourGoodJets();
    case TTbarEPlusJetsSelection::Zveto:
        return isNotAZBosonEvent();
    default:
        return false;
    }
}

bool TopPairEventCandidate::passesRelIsoSelection() const{
    bool passesFirst3 = passesSelectionStepUpTo(TTbarEPlusJetsSelection::GoodPrimaryvertex);
        bool passGoodElectrons = goodElectrons.size() > 0 && goodIsolatedElectrons.size() < 2;
        bool passesBothIsolationvetos = false;
        if (passGoodElectrons) {
            const ElectronPointer electron = MostIsolatedElectron();
            if (electron->isGood()) {
                if (useCustomConversionTagger) {
                    conversionTagger->calculateConversionVariables(electron, tracks, 3.8, 0.45);
                    passesBothIsolationvetos = electron->isFromConversion() == false && conversionTagger->isFromConversion(
                            0.02, 0.02) == false;
                }
                else{
                    passesBothIsolationvetos = electron->isFromConversion() == false && electron->isTaggedAsConversion(
                            0.02, 0.02) == false;
                }
            }

        }
        bool muonVeto = hasNoIsolatedMuon();
        bool Zveto = isNotAZBosonEvent();
        return passesFirst3 && passGoodElectrons && passesBothIsolationvetos && muonVeto && Zveto;
}

bool TopPairEventCandidate::passesRelIsoControlSelection() const{
    bool passesFirst3 = passesSelectionStepUpTo(TTbarEPlusJetsSelection::GoodPrimaryvertex);
       bool passGoodElectrons = allElectrons.size() > 0 && goodIsolatedElectrons.size() < 2;
       bool passesBothIsolationvetos = false;
       if (passGoodElectrons) {
           const ElectronPointer electron = MostIsolatedElectron();
           if (electron->isQCDElectron()) {
               if (useCustomConversionTagger) {
                   conversionTagger->calculateConversionVariables(electron, tracks, 3.8, 0.45);
                   passesBothIsolationvetos = electron->isFromConversion() == false && conversionTagger->isFromConversion(
                           0.02, 0.02) == false;
               } else {
                   passesBothIsolationvetos = electron->isFromConversion() == false && electron->isTaggedAsConversion(
                           0.02, 0.02) == false;
               }
           }

       }
       bool muonVeto = hasNoIsolatedMuon();
       bool Zveto = isNotAZBosonEvent();
       return passesFirst3 && passGoodElectrons && passesBothIsolationvetos && muonVeto && Zveto;
}

bool TopPairEventCandidate::passesPFIsoSelection() const{
    bool passesFirst3 = passesSelectionStepUpTo(TTbarEPlusJetsSelection::GoodPrimaryvertex);
        bool passGoodElectrons = goodElectrons.size() > 0 && goodPFIsolatedElectrons.size() < 2;
        bool passesBothIsolationvetos = false;
        if (passGoodElectrons) {
            const ElectronPointer electron = MostPFIsolatedElectron();
            if (electron->isGood()) {
                if (useCustomConversionTagger) {
                    conversionTagger->calculateConversionVariables(electron, tracks, 3.8, 0.45);
                    passesBothIsolationvetos = electron->isFromConversion() == false && conversionTagger->isFromConversion(
                            0.02, 0.02) == false;
                }
                else{
                    passesBothIsolationvetos = electron->isFromConversion() == false && electron->isTaggedAsConversion(
                            0.02, 0.02) == false;
                }
            }

        }
        bool muonVeto = hasNoIsolatedMuon();
        bool Zveto = isNotAZBosonEvent();
        return passesFirst3 && passGoodElectrons && passesBothIsolationvetos && muonVeto && Zveto;
}

bool TopPairEventCandidate::passesPFIsoControlSelection() const{
    bool passesFirst3 = passesSelectionStepUpTo(TTbarEPlusJetsSelection::GoodPrimaryvertex);
       bool passGoodElectrons = allElectrons.size() > 0 && goodPFIsolatedElectrons.size() < 2;
       bool passesBothIsolationvetos = false;
       if (passGoodElectrons) {
           const ElectronPointer electron = MostPFIsolatedElectron();
           if (electron->isQCDElectron()) {
               if (useCustomConversionTagger) {
                   conversionTagger->calculateConversionVariables(electron, tracks, 3.8, 0.45);
                   passesBothIsolationvetos = electron->isFromConversion() == false && conversionTagger->isFromConversion(
                           0.02, 0.02) == false;
               } else {
                   passesBothIsolationvetos = electron->isFromConversion() == false && electron->isTaggedAsConversion(
                           0.02, 0.02) == false;
               }
           }

       }
       bool muonVeto = hasNoIsolatedMuon();
       bool Zveto = isNotAZBosonEvent();
       return passesFirst3 && passGoodElectrons && passesBothIsolationvetos && muonVeto && Zveto;
}

bool TopPairEventCandidate::passesConversionSelection() const {
    bool passesFirst6 = passesSelectionStepUpTo(TTbarEPlusJetsSelection::Zveto);
    bool isConversion1 = isolatedElectronDoesNotComeFromConversion() == false;
    bool isConversion2 = isolatedElectronNotTaggedAsFromConversion() == false;
    bool atLeast4Jets = hasAtLeastFourGoodJets();
    return passesFirst6 && (isConversion1 || isConversion2) && atLeast4Jets;
}

bool TopPairEventCandidate::passesAntiIsolationSelection() const {
    //require at least one good electron and no isolated good electrons
    if (!(goodElectrons.size() > 0 && goodIsolatedElectrons.size() == 0))
            return false;

    bool passesFirst3 = passesSelectionStep(TTbarEPlusJetsSelection::GoodPrimaryvertex);


    bool muonVeto = passesSelectionStep(TTbarEPlusJetsSelection::LooseMuonVeto);
    bool zveto = passesSelectionStep(TTbarEPlusJetsSelection::Zveto);
    bool conversionVeto = (goodElectrons.front()->isFromConversion() || goodElectrons.front()->isTaggedAsConversion(
            0.2, 0.2)) == false;
    bool jets = hasAtLeastFourGoodJets();
    return passesFirst3 && muonVeto && zveto && conversionVeto && jets;
}

void TopPairEventCandidate::reconstructTTbar(ElectronPointer electron) {
    if (goodJets.size() < 4)
      throw ReconstructionException("Not enough jets available to reconstruct top event using Mass Equality method.");
    electronFromW = electron;
    selectedNeutrino = 0;
    currentSelectedNeutrino = 0;
    reconstructNeutrinos();
    double chosen_TopMassDifference(9999999.);
    double chosen_Chi2Total(9999999.);

    for (unsigned short hadBindex = 0; hadBindex < goodJets.size(); ++hadBindex) {
            for (unsigned short lepBindex = 0; lepBindex < goodJets.size(); ++lepBindex) {
                if (lepBindex == hadBindex)
                    continue;
                for (unsigned short jet1Index = 0; jet1Index < goodJets.size(); ++jet1Index) {
                    if (jet1Index == lepBindex || jet1Index == hadBindex)
                        continue;
                    for (unsigned short jet2Index = 0; jet2Index < goodJets.size(); ++jet2Index) {
                        if (jet2Index == jet1Index || jet2Index == lepBindex || jet2Index == hadBindex)
                            continue;
                        hadronicBJet = goodJets.at(hadBindex);
                        leptonicBJet = goodJets.at(lepBindex);
                        jet1FromW = goodJets.at(jet1Index);
                        jet2FromW = goodJets.at(jet2Index);

                        leptonicW1 = ParticlePointer(new Particle(*neutrino1 + *electronFromW));
                        leptonicW2 = ParticlePointer(new Particle(*neutrino2 + *electronFromW));
                        hadronicW = ParticlePointer(new Particle(*jet1FromW + *jet2FromW));
                        leptonicTop1 = ParticlePointer(new Particle(*leptonicBJet + *leptonicW1));
                        leptonicTop2 = ParticlePointer(new Particle(*leptonicBJet + *leptonicW2));
                        hadronicTop = ParticlePointer(new Particle(*hadronicBJet + *hadronicW));
                        fillHypotheses();
                        selectNeutrinoSolution();
                        double TopMassDifference = calculateTopMassDifference(currentSelectedNeutrino);
                        double chi2 = getTotalChi2(currentSelectedNeutrino);
                        switch (usedTTbarReconstruction) {
                        case TTbarReconstructionCriterion::TopMassDifference:
                          if (TopMassDifference < chosen_TopMassDifference) {
                            hadronicBIndex = hadBindex;
                            leptonicBIndex = lepBindex;
                            jet1FromWIndex = jet1Index;
                            jet2FromWIndex = jet2Index;
                            chosen_TopMassDifference = TopMassDifference;
                            selectedNeutrino = currentSelectedNeutrino;
                          }
                          break;

                        case TTbarReconstructionCriterion::chi2:
                          if (chi2 < chosen_Chi2Total) {
                            hadronicBIndex = hadBindex;
                            leptonicBIndex = lepBindex;
                            jet1FromWIndex = jet1Index;
                            jet2FromWIndex = jet2Index;
                            chosen_Chi2Total = chi2;
                            selectedNeutrino = currentSelectedNeutrino;
                          }
                          break;
                        }
                    }
                }
            }
  }
    std::sort(solutions.begin(), solutions.end(), compareSolutions);
    hadronicBJet = goodJets.at(hadronicBIndex);
    leptonicBJet = goodJets.at(leptonicBIndex);
    jet1FromW = goodJets.at(jet1FromWIndex);
    jet2FromW = goodJets.at(jet2FromWIndex);
    leptonicW1 = ParticlePointer(new Particle(*neutrino1 + *electronFromW));
    leptonicW2 = ParticlePointer(new Particle(*neutrino2 + *electronFromW));
    hadronicW = ParticlePointer(new Particle(*jet1FromW + *jet2FromW));
    leptonicTop1 = ParticlePointer(new Particle(*leptonicBJet + *leptonicW1));
    leptonicTop2 = ParticlePointer(new Particle(*leptonicBJet + *leptonicW2));
    hadronicTop = ParticlePointer(new Particle(*hadronicBJet + *hadronicW));
    if (selectedNeutrino == 1)
      ttbarResonance = ParticlePointer(new Particle(*leptonicTop1 + *hadronicTop));
    else
      ttbarResonance = ParticlePointer(new Particle(*leptonicTop2 + *hadronicTop));
    doneReconstruction = true;
}


void TopPairEventCandidate::reconstructNeutrinos() {
    boost::array<double, 2> neutrinoPzs = computeNeutrinoPz();
    double energy1 = sqrt(met->et() * met->et() + neutrinoPzs.at(0) * neutrinoPzs.at(0));
    double energy2 = sqrt(met->et() * met->et() + neutrinoPzs.at(1) * neutrinoPzs.at(1));
    neutrino1 = ParticlePointer(new Particle(energy1, met->px(), met->py(), neutrinoPzs.at(0)));
    neutrino2 = ParticlePointer(new Particle(energy2, met->px(), met->py(), neutrinoPzs.at(1)));

    if (isnan(neutrino1->energy()) && isnan(neutrino2->energy()))
        throw ReconstructionException("No physical neutrino solution found");
    else if (isnan(neutrino1->energy()))
        neutrino1 = neutrino2;
    else if (isnan(neutrino2->energy()))
        neutrino2 = neutrino1;
}

const boost::array<double, 2> TopPairEventCandidate::computeNeutrinoPz() {
    if (electronFromW == 0)
        throw ReconstructionException("Could not reconstruct neutrinos: no isolated electrons found");
    if (met->energy() == 0)
        throw ReconstructionException("Could not reconstruct neutrinos: no MET found");
    boost::array<double, 2> neutrinoPzs;
    //    const ElectronPointer electron = goodIsolatedElectrons.front();

    double pz1(0), pz2(0);
    //    double M_W = 80.389;
    double M_e = 0.0005;
    double ee = electronFromW->energy();
    double pxe = electronFromW->px();
    double pye = electronFromW->py();
    double pze = electronFromW->pz();
    double pxnu = met->px();
    double pynu = met->py();

    double a = W_mass * W_mass - M_e * M_e + 2.0 * pxe * pxnu + 2.0 * pye * pynu;
    double A = 4.0 * (ee * ee - pze * pze);
    double B = -4.0 * a * pze;
    double C = 4.0 * ee * ee * (pxnu * pxnu + pynu * pynu) - a * a;

    double tmproot = B * B - 4.0 * A * C;
    if (tmproot < 0) {
        pz1 = pz2 = -B / (2 * A);
    } else {
        pz1 = (-B + TMath::Sqrt(tmproot)) / (2.0 * A);
        pz2 = (-B - TMath::Sqrt(tmproot)) / (2.0 * A);

    }
    neutrinoPzs[0] = pz1;
    neutrinoPzs[1] = pz2;
    return neutrinoPzs;
}


void TopPairEventCandidate::fillHypotheses() {
  TtbarHypothesisPointer hypothesis1(fillHypothesis(1));
  TtbarHypothesisPointer hypothesis2(fillHypothesis(2));
  solutions.push_back(hypothesis1);
  solutions.push_back(hypothesis2);

}

const TtbarHypothesisPointer TopPairEventCandidate::fillHypothesis(unsigned short int neutrinoSolution) {
  TtbarHypothesisPointer hypothesis(new TtbarHypothesis());
  hypothesis->electronFromW = electronFromW;
  hypothesis->leptonicBjet = leptonicBJet;
  hypothesis->hadronicBJet = hadronicBJet;
  hypothesis->jet1FromW = jet1FromW;
  hypothesis->jet2FromW = jet2FromW;
  hypothesis->hadronicW = hadronicW;
  hypothesis->hadronicTop = hadronicTop;
  hypothesis->hadronicChi2 = getHadronicChi2();
  if(neutrinoSolution == 1) {
    hypothesis->neutrinoFromW = neutrino1;
    hypothesis->leptonicW = leptonicW1;
    hypothesis->leptonicTop = leptonicTop1;
  }
  else {
    hypothesis->neutrinoFromW = neutrino2;
    hypothesis->leptonicW = leptonicW2;
    hypothesis->leptonicTop = leptonicTop2;
  }

  hypothesis->totalChi2 = getTotalChi2(neutrinoSolution);
  hypothesis->globalChi2 = getGlobalChi2(neutrinoSolution);
  hypothesis->leptonicChi2 = getLeptonicChi2(neutrinoSolution);
  ParticlePointer resonance(new Particle(*hypothesis->leptonicTop + *hypothesis->hadronicTop));
  hypothesis->resonance = resonance;
  return hypothesis;
}

void TopPairEventCandidate::selectNeutrinoSolution() {

    if (leptonicTop1->mass() < 0 && leptonicTop2->mass() < 0) {
        inspectReconstructedEvent();
        throw ReconstructionException("No valid neutrino solution found");
    } else if (leptonicTop1->mass() < 0 && leptonicTop2->mass() > 0) {
        currentSelectedNeutrino = 2;
    } else if (leptonicTop1->mass() > 0 && leptonicTop2->mass() < 0) {
        currentSelectedNeutrino = 1;
    } else {// both solutions give positive mass
        switch (usedNeutrinoSelection) {
        case NeutrinoSelectionCriterion::TopMassDifference:
            fabs(leptonicTop1->mass()-hadronicTop->mass()) < fabs(leptonicTop2->mass()-hadronicTop->mass()) ?
                      currentSelectedNeutrino = 1 : currentSelectedNeutrino = 2;
            break;
        case NeutrinoSelectionCriterion::chi2:
            getTotalChi2(1) < getTotalChi2(2) ? currentSelectedNeutrino = 1 : currentSelectedNeutrino = 2;
            break;

        case NeutrinoSelectionCriterion::pzClosestToLepton:
            fabs(neutrino1->pz() - electronFromW->pz()) < fabs(neutrino2->pz()
                    - electronFromW->pz()) ? currentSelectedNeutrino = 1 : currentSelectedNeutrino = 2;
            break;

        case NeutrinoSelectionCriterion::mostCentral:
            fabs(neutrino1->pz()) < fabs(neutrino2->pz()) ? currentSelectedNeutrino = 1 : currentSelectedNeutrino = 2;
            break;

        case NeutrinoSelectionCriterion::pzClosestToLeptonOrMostcentralIfAbove300:
            fabs(neutrino1->pz() - electronFromW->pz()) < fabs(neutrino2->pz()
                    - electronFromW->pz()) ? currentSelectedNeutrino = 1 : currentSelectedNeutrino = 2;
            if (fabs(neutrino1->pz()) > 300 || fabs(neutrino2->pz()) > 300)
                fabs(neutrino1->pz()) < fabs(neutrino2->pz()) ? currentSelectedNeutrino = 1 : currentSelectedNeutrino
                        = 2;
            break;

        case NeutrinoSelectionCriterion::largestValueOfCosine:
            TVector3 p3W, p3e;
            //TODO clean up
            p3W = leptonicW1->getFourVector().Vect();
            p3e = electronFromW->getFourVector().Vect();

            double sinthcm1 = 2. * (p3e.Perp(p3W)) / W_mass;
            p3W = leptonicW2->getFourVector().Vect();
            double sinthcm2 = 2. * (p3e.Perp(p3W)) / W_mass;

            double costhcm1 = TMath::Sqrt(1. - sinthcm1 * sinthcm1);
            double costhcm2 = TMath::Sqrt(1. - sinthcm2 * sinthcm2);
            costhcm1 > costhcm2 ? currentSelectedNeutrino = 1 : currentSelectedNeutrino = 2;
            break;

        }
    }

}

double TopPairEventCandidate::calculateTopMassDifference(unsigned short int neutrinoSolution) const {

  double LeptonicTop1MassDifference = fabs(leptonicTop1->mass()-hadronicTop->mass());
  double LeptonicTop2MassDifference = fabs(leptonicTop2->mass()-hadronicTop->mass());

  if (neutrinoSolution == 1)
    return LeptonicTop1MassDifference;
  else
    return LeptonicTop2MassDifference;

}

double TopPairEventCandidate::getTotalChi2() {
    double totalChi2(9999999);
    double firstTotalChi2 = getTotalChi2(1);
    double secondTotalChi2 = getTotalChi2(2);
    selectedNeutrino == 1 ? totalChi2 = firstTotalChi2 : totalChi2 = secondTotalChi2;
    //    if (firstTotalChi2 < secondTotalChi2) {
    //        selectedNeutrino = 1;
    //        totalChi2 = firstTotalChi2;
    //    } else {
    //        selectedNeutrino = 2;
    //        totalChi2 = secondTotalChi2;
    //    }
    return totalChi2;
}

double TopPairEventCandidate::getTotalChi2(unsigned short int neutrinoSolution) const {
    return getLeptonicChi2(neutrinoSolution) + getHadronicChi2() + getGlobalChi2(neutrinoSolution);
}

double TopPairEventCandidate::getLeptonicChi2(unsigned short int neutrinoSolution) const {
    double topMass(0);
    double angle = leptonicBJet->angle(electronFromW);
    if (neutrinoSolution == 1)
        topMass = leptonicTop1->mass();
    else
        topMass = leptonicTop2->mass();

    return getLeptonicChi2(topMass, angle);
}

double TopPairEventCandidate::getLeptonicChi2(double topMass, double angle) const {
    double massDifference = TMath::Power(topMass - matched_leptonic_top_mass, 2);
    double massError = 2 * matched_leptonic_top_mass_sigma * matched_leptonic_top_mass_sigma;
    double massTerm = massDifference / massError;

    double angleDifference = TMath::Power(angle - matched_angle, 2);
    double angleError = 2 * matched_angle_sigma * matched_angle_sigma;
    double angleTerm = angleDifference / angleError;
    return 1 / sqrt(2) * (angleTerm + massTerm);
}

double TopPairEventCandidate::getHadronicChi2() const {
    double ptRatioDifference = TMath::Power(PtRatio() - matched_ptratio, 2);
    double ptRatioError = 2 * matched_ptratio_sigma * matched_ptratio_sigma;
    double ptRatioTerm = ptRatioDifference / ptRatioError;

    double WmassDifference = TMath::Power(hadronicW->mass() - matched_hadronic_W_mass, 2);
    double WmassError = 2 * matched_hadronic_W_mass_sigma * matched_hadronic_W_mass_sigma;
    double WmassTerm = WmassDifference / WmassError;

    double topMassDifference = TMath::Power(hadronicTop->mass() - matched_hadronic_top_mass, 2);
    double topMassError = 2 * matched_hadronic_top_mass_sigma * matched_hadronic_top_mass_sigma;
    double topMassTerm = topMassDifference / topMassError;
    return 1 / sqrt(3) * (topMassTerm + WmassTerm + ptRatioTerm);
    return 0;
}

double TopPairEventCandidate::PtRatio() const {
    return TMath::Log(hadronicTop->pt() / hadronicW->pt());
}

double TopPairEventCandidate::getGlobalChi2(unsigned short neutrinoSolution) const {
    double pttbar = PtTtbarSystem(neutrinoSolution);
    double pttbarDifference = TMath::Power(pttbar - matched_pt_ttbarSystem, 2);
    double pttbarError = (2 * matched_pt_ttbarSystem_sigma * matched_pt_ttbarSystem_sigma);
    double pttbarTerm = pttbarDifference / pttbarError;

    double htSystemDifference = TMath::Power(HTSystem() - matched_HTSystem, 2);
    double htSystemError = matched_HTSystem_sigma * matched_HTSystem_sigma * 2;
    double htSystemTerm = htSystemDifference / htSystemError;
    return 1 / sqrt(2) * (pttbarTerm + htSystemTerm);
}

double TopPairEventCandidate::PtTtbarSystem(unsigned short neutrinoSolution) const {
    ParticlePointer combined;
    if (neutrinoSolution == 1)
        combined = ParticlePointer(new Particle(*leptonicTop1 + *hadronicTop));
    else
        combined = ParticlePointer(new Particle(*leptonicTop2 + *hadronicTop));
    return combined->pt();
}

double TopPairEventCandidate::HT(unsigned short jetLimit) const {
    double HT(0);
    unsigned short limit = goodJets.size();
    if (limit > jetLimit + 1)
        limit = jetLimit + 1;

    for (unsigned short index = 0; index < limit; ++index)
        HT += goodJets.at(index)->pt();

    return HT;
}

double TopPairEventCandidate::HTSystem() const {
    return sumPt() / HT(8);
}

double TopPairEventCandidate::sumPt() const {
    return leptonicBJet->pt() + hadronicBJet->pt() + jet1FromW->pt() + jet2FromW->pt();
}

void TopPairEventCandidate::throwExpeptionIfNotReconstructed() const {
    if (doneReconstruction == false)
        throw ReconstructionException("Can't access reconstructed particles before reconstruction.");
}

const ElectronPointer TopPairEventCandidate::getElectronFromWDecay() const {
    return electronFromW;
}

const ParticlePointer TopPairEventCandidate::getNeutrinoFromWDecay() const {
    throwExpeptionIfNotReconstructed();
    if (selectedNeutrino == 1)
        return neutrino1;
    else
        return neutrino2;
}

const JetPointer TopPairEventCandidate::getHadronicBJet() const {
    throwExpeptionIfNotReconstructed();
    return hadronicBJet;
}

const JetPointer TopPairEventCandidate::getLeptonicBJet() const {
    throwExpeptionIfNotReconstructed();
    return leptonicBJet;
}


const ParticlePointer TopPairEventCandidate::getLeptonicW() const
{
    throwExpeptionIfNotReconstructed();
    if (selectedNeutrino == 1)
        return leptonicW1;
    else
        return leptonicW2;
}


const JetPointer TopPairEventCandidate::getJet1FromHadronicW() const {
    throwExpeptionIfNotReconstructed();
    return jet1FromW;
}

const JetPointer TopPairEventCandidate::getJet2FromHadronicW() const {
    throwExpeptionIfNotReconstructed();
    return jet2FromW;
}

const ParticlePointer TopPairEventCandidate::getLeptonicTop() const {
    throwExpeptionIfNotReconstructed();
    if (selectedNeutrino == 1)
        return leptonicTop1;
    else
        return leptonicTop2;
}

const ParticlePointer TopPairEventCandidate::getHadronicTop() const {
    throwExpeptionIfNotReconstructed();
    return hadronicTop;
}

const ParticlePointer TopPairEventCandidate::getResonance() const {
    throwExpeptionIfNotReconstructed();
    return ttbarResonance;
}

double TopPairEventCandidate::M3() const {
    double m3(0), max_pt(0);
    if (goodJets.size() >= 3) {
        for (unsigned int index1 = 0; index1 < goodJets.size() - 2; ++index1) {
            for (unsigned int index2 = index1 + 1; index2 < goodJets.size() - 1; ++index2) {
                for (unsigned int index3 = index2 + 1; index3 < goodJets.size(); ++index3) {
                    FourVector m3Vector(goodJets.at(index1)->getFourVector() + goodJets.at(index2)->getFourVector()
                            + goodJets.at(index3)->getFourVector());
                    double currentPt = m3Vector.Pt();
                    if (currentPt > max_pt) {
                        max_pt = currentPt;
                        m3 = m3Vector.M();
                    }
                }
            }
        }
    }

    return m3;
}


double TtbarHypothesis::M3() const {
    double m3(0), max_et(0);
    JetCollection mcJets;
    mcJets.clear();
    mcJets.push_back(jet1FromW);
    mcJets.push_back(jet2FromW);
    mcJets.push_back(leptonicBjet);
    mcJets.push_back(hadronicBJet);
    if (mcJets.size() >= 3) {
        for (unsigned int index1 = 0; index1 < mcJets.size() - 2; ++index1) {
            for (unsigned int index2 = index1 + 1; index2 < mcJets.size() - 1; ++index2) {
                for (unsigned int index3 = index2 + 1; index3 < mcJets.size(); ++index3) {
                    FourVector m3Vector(mcJets.at(index1)->getFourVector() + mcJets.at(index2)->getFourVector()
                            + mcJets.at(index3)->getFourVector());
                    double currentEt = m3Vector.Et();
                    if (currentEt > max_et) {
                        max_et = currentEt;
                        m3 = m3Vector.M();
                    }
                }
            }
        }
    }

    return m3;
}

double TopPairEventCandidate::mttbar() const {
    return getResonance()->mass();
}

const std::vector<TtbarHypothesisPointer>& TopPairEventCandidate::Solutions() const{
  return solutions;
}

void TopPairEventCandidate::inspectReconstructedEvent() const {
    cout << "run " << runNumber << ", event " << eventNumber << endl;
    cout << "leptonic b jet, goodJet index " << leptonicBIndex << endl;
    EventContentPrinter::printJet(leptonicBJet);

    cout << "electron from W" << endl;
    EventContentPrinter::printElectron(electronFromW);

    cout << "MET" << endl;
    EventContentPrinter::printParticle(met);
    cout << endl;

    cout << "reconstructed neutrino 1(selected: " << selectedNeutrino << ")" << endl;
    EventContentPrinter::printParticle(neutrino1);
    cout << endl;

    cout << "reconstructed neutrino 2(selected: " << selectedNeutrino << ")" << endl;
    EventContentPrinter::printParticle(neutrino2);
    cout << endl;

    cout << "leptonic W 1 (selected: " << selectedNeutrino << ")" << endl;
    EventContentPrinter::printParticle(leptonicW1);
    cout << endl;

    cout << "leptonic W 2 (selected: " << selectedNeutrino << ")" << endl;
    EventContentPrinter::printParticle(leptonicW2);
    cout << endl;

    cout << "leptonic top 1 (selected: " << selectedNeutrino << ")" << endl;
    EventContentPrinter::printParticle(leptonicTop1);
    cout << endl;

    cout << "leptonic top 2 (selected: " << selectedNeutrino << ")" << endl;
    EventContentPrinter::printParticle(leptonicTop2);
    cout << endl;

    cout << "hadronic b jet, goodJet index " << hadronicBIndex << endl;
    EventContentPrinter::printJet(hadronicBJet);

    cout << "jet1 from W, goodJet index " << jet1FromWIndex << endl;
    EventContentPrinter::printJet(jet1FromW);

    cout << "jet 2 from W, goodJet index " << jet2FromWIndex << endl;
    EventContentPrinter::printJet(jet2FromW);

    cout << "hadronic W" << endl;
    EventContentPrinter::printParticle(hadronicW);
    cout << endl;

    cout << "hadronic top" << endl;
    EventContentPrinter::printParticle(hadronicTop);
    cout << endl;
}

double TopPairEventCandidate::fullHT() const {
    double ht(met->pt());

    for (unsigned int index = 0; index < goodIsolatedElectrons.size(); ++index) {
        ht += goodIsolatedElectrons.at(index)->pt();
    }

    for (unsigned int index = 0; index < goodIsolatedMuons.size(); ++index) {
        ht += goodIsolatedMuons.at(index)->pt();
    }

    for (unsigned int index = 0; index < goodJets.size(); ++index) {
        ht += goodJets.at(index)->pt();
    }
    return ht;
}

double TopPairEventCandidate::transverseWmass(const ElectronPointer electron) const {
    double energySquared = pow(electron->et() + met->et(), 2);
    double momentumSquared = pow(electron->px() + met->px(), 2) + pow(electron->py() + met->py(), 2);
    double tMassSquared = energySquared - momentumSquared;

    if (tMassSquared > 0)
        return sqrt(tMassSquared);
    else
        return -1;
}

void TopPairEventCandidate::reconstruct(Rule rule, const ElectronPointer electron) {
    //TODO: change this into if(!Rule::meetsInitialConditaion())
    if (goodJets.size() < 4 || electron == 0)
          throw ReconstructionException("Not enough jets available to reconstruct top event using Mass Equality method.");
        electronFromW = electron;
        selectedNeutrino = 0;
        currentSelectedNeutrino = 0;

        reconstructNeutrinos();
        double chosen_TopMassDifference(9999999.);
        double chosen_Chi2Total(9999999.);
    for (unsigned short hadBindex = 0; hadBindex < goodJets.size(); ++hadBindex) {
        if (rule->hardHadronicBJetCondition(goodJets.at(hadBindex)))
            continue;

        for (unsigned short lepBindex = 0; lepBindex < goodJets.size(); ++lepBindex) {
            if (lepBindex == hadBindex || rule->hardLeptonicBJetCondition(goodJets.at(lepBindex)))
                continue;

            for (unsigned short jet1Index = 0; jet1Index < goodJets.size(); ++jet1Index) {
                if (jet1Index == lepBindex || jet1Index == hadBindex || rule->hardHadronicJetFromWCondition(
                        goodJets.at(jet1Index)))
                    continue;

                for (unsigned short jet2Index = 0; jet2Index < goodJets.size(); ++jet2Index) {
                    if (jet2Index == jet1Index || jet2Index == lepBindex || jet2Index == hadBindex
                            || rule->hardHadronicJetFromWCondition(goodJets.at(jet2Index)))
                        continue;

                    hadronicBJet = goodJets.at(hadBindex);
                    leptonicBJet = goodJets.at(lepBindex);
                    jet1FromW = goodJets.at(jet1Index);
                    jet2FromW = goodJets.at(jet2Index);

                    leptonicW1 = ParticlePointer(new Particle(*neutrino1 + *electronFromW));
                    leptonicW2 = ParticlePointer(new Particle(*neutrino2 + *electronFromW));
                    hadronicW = ParticlePointer(new Particle(*jet1FromW + *jet2FromW));
                    leptonicTop1 = ParticlePointer(new Particle(*leptonicBJet + *leptonicW1));
                    leptonicTop2 = ParticlePointer(new Particle(*leptonicBJet + *leptonicW2));
                    hadronicTop = ParticlePointer(new Particle(*hadronicBJet + *hadronicW));
                    fillHypotheses();
                    selectNeutrinoSolution();
                    double TopMassDifference = calculateTopMassDifference(currentSelectedNeutrino);
                    double chi2 = getTotalChi2(currentSelectedNeutrino);
                    switch (usedTTbarReconstruction) {
                    case TTbarReconstructionCriterion::TopMassDifference:
                        if (TopMassDifference < chosen_TopMassDifference) {
                            hadronicBIndex = hadBindex;
                            leptonicBIndex = lepBindex;
                            jet1FromWIndex = jet1Index;
                            jet2FromWIndex = jet2Index;
                            chosen_TopMassDifference = TopMassDifference;
                            selectedNeutrino = currentSelectedNeutrino;
                        }
                        break;

                    case TTbarReconstructionCriterion::chi2:
                        if (chi2 < chosen_Chi2Total) {
                            hadronicBIndex = hadBindex;
                            leptonicBIndex = lepBindex;
                            jet1FromWIndex = jet1Index;
                            jet2FromWIndex = jet2Index;
                            chosen_Chi2Total = chi2;
                            selectedNeutrino = currentSelectedNeutrino;
                        }
                        break;
                    }
                }
            }
        }
    }
    compare_disc sorting;
    std::sort(solutions.begin(), solutions.end(), sorting);
    hadronicBJet = solutions.front()->hadronicBJet;
    leptonicBJet = solutions.front()->leptonicBjet;
    jet1FromW = solutions.front()->jet1FromW;
    jet2FromW = solutions.front()->jet2FromW;
    leptonicW1 = solutions.front()->leptonicW;
    leptonicW2 = solutions.front()->leptonicW;
    hadronicW = solutions.front()->hadronicW;
//    leptonicW1 = ParticlePointer(new Particle(*neutrino1 + *electronFromW));
//    leptonicW2 = ParticlePointer(new Particle(*neutrino2 + *electronFromW));
//    hadronicW = ParticlePointer(new Particle(*jet1FromW + *jet2FromW));
    leptonicTop1 = solutions.front()->leptonicTop;
    leptonicTop2 = solutions.front()->leptonicTop;
    hadronicTop = solutions.front()->hadronicTop;
    ttbarResonance = solutions.front()->resonance;
    if (selectedNeutrino == 1)
        ttbarResonance = ParticlePointer(new Particle(*leptonicTop1 + *hadronicTop));
    else
        ttbarResonance = ParticlePointer(new Particle(*leptonicTop2 + *hadronicTop));
    doneReconstruction = true;
}

}


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/CrossSections.h
//***********************************************************************


/*
 * CrossSections.h
 *
 *  Created on: 29 Jul 2010
 *      Author: kreczko
 */

#ifndef CROSSSECTIONS_H_
#define CROSSSECTIONS_H_
//https://twiki.cern.ch/twiki/bin/view/CMS/CrossSections_3XSeries#crosssections

#include "DataTypes.h"
#include <vector>
#include <boost/array.hpp>

namespace BAT {
namespace sevenTeV {
extern boost::array<float, DataType::NUMBER_OF_DATA_TYPES> getXSections();
}


struct CrossSectionProvider{
private:
    float lumiInInversePb;
    unsigned short tev;
    bool useSkimEff;
    boost::array<float, DataType::NUMBER_OF_DATA_TYPES> xsection;
    boost::array<unsigned long, DataType::NUMBER_OF_DATA_TYPES> numberOfProducedEvents;
    boost::array<unsigned long, DataType::NUMBER_OF_DATA_TYPES> numberOfSkimmedEvents;
    void defineNumberOfSkimmedEvents();
    void defineNumberOfProducedEvents();
public:


    CrossSectionProvider(float lumiInInversePb, unsigned short tev = 7);
    ~CrossSectionProvider();

    void useSkimEfficiency(bool use);

    float getExpectedNumberOfEvents(DataType::value type);
    float getWeight(DataType::value type);

};
}

#endif /* CROSSSECTIONS_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/RecoCandidateBase.h
//***********************************************************************


/*
 * RecoCandidateBase.h
 *
 *  Base class for reconstructed candidates
 *
 *  To create a new reconstructed candidate, called "mycandidate", for example,
 *  do the following in a new header file:

#include "RecoCandidateBase.h"


namespace OAT {

class mycandidate: public RecoCandidateBase {

public:
    mycandidate()
    {}

    mycandidate(const Event& event) :
      RecoCandidateBase(event)
    {}

    virtual bool passesFullSelection() const;
    virtual void reconstructCandidate(const ElectronPointer &electron);
    
    // The following is an example member function that would return the mass
    // of the candidate.  You could create other functions instead.
    virtual double getMass() const;
    
    
    // Add other functions here that return the values you want to plot.

protected:

//  Your data members,if any, should be declared here.

};
}

Then you have to code the last three functions in a new file you create in the
"src" directory.  Make sure to add the following lines to the top of your
source code file:

#include "../interface/RecoCandidateBase.h"

using namespace OAT;

After completing the code for "mycandidate", you can put calls to your class
in IntroAnalysis.h and IntroAnalysis.cpp.  Add the declaration of your
candidate to the "private" section of the IntroAnalysis class where other
candidates are declared.  Then, in IntroAnalysis.cpp, instantiate your
candidate in the initiateEvent member function where the other candidates
are instantiated.

Then you should write your own analysis function that will
check if the current event should be selected by calling passesFullSelection,
and, if so, reconstruct it with reconstructCandidate and then add its mass to
a histogram with getMass.  See doTTBarAnalysis in IntroAnalysis.cpp for an
example of an analysis function.  You need to add a call to your analysis
function in the main event loop of the "analyze" function.

 */
 

#ifndef RECOCANDIDATEBASE_H_
#define RECOCANDIDATEBASE_H_

#include <boost/shared_ptr.hpp>

#include "Event.h"
#include "RecoObjects/Particle.h"
#include "RecoObjects/Electron.h"
#include "RecoObjects/Jet.h"


using namespace BAT;

namespace OAT {

class RecoCandidateBase: public Event {

public:

    RecoCandidateBase()
    {}

    RecoCandidateBase(const Event& event) :
      Event(event)
    {}

    virtual ~RecoCandidateBase()
    {}

    virtual bool passesFullSelection() const = 0;

    /*
    Sample reconstruction function:

    virtual void reconstructCandidate(const ElectronPointer &electron);

    Note your reconstruction function may not take a parameter or may
    take different parameters from this example.
    */

};

}

#endif /* RECOCANDIDATEBASE_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/Event.h
//***********************************************************************


/*
 * Event.h
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#ifndef EVENT_H_
#define EVENT_H_
#include "RecoObjects/Electron.h"
#include "RecoObjects/Jet.h"
#include "RecoObjects/Muon.h"
#include "RecoObjects/Vertex.h"
#include "RecoObjects/MET.h"
#include "RecoObjects/MCParticle.h"
#include "DataTypes.h"
#include "Printers/EventContentPrinter.h"
#include "HighLevelTriggers.h"

namespace BAT {


class Event {
protected:
    boost::shared_ptr<std::vector<int> > HLTs;
    VertexCollection vertices;
    TrackCollection tracks;
    ElectronCollection allElectrons;
    ElectronCollection goodElectrons;
    ElectronCollection goodIsolatedElectrons;
    ElectronCollection goodPFIsolatedElectrons;
    ElectronCollection looseElectrons;
    ElectronCollection qcdElectrons;

    JetCollection allJets;
    JetCollection genJets;
    JetCollection goodJets;
    JetCollection goodBJets;

    MuonCollection allMuons;
    MuonCollection goodMuons;
    MuonCollection goodIsolatedMuons;

    MCParticleCollection genParticles;

    METPointer met;

    DataType::value dataType;
    unsigned long runNumber;
    unsigned long eventNumber;
    unsigned long localEventNumber;
    unsigned long lumiBlock;
    float eventWeight;

    float jetCleaningEfficiency;
    unsigned int numberOfHighPurityTracks;
    bool isBeamScraping;

public:
    Event();
    virtual ~Event();
    bool isRealData() const;
    const DataType::value getDataType() const;
    void setDataType(DataType::value type);
    void setVertices(VertexCollection vertices);
    void setTracks(TrackCollection tracks);
    void setGenParticles(MCParticleCollection genParticles);
    void setElectrons(ElectronCollection electrons);
    void setJets(JetCollection jets);
    void setGenJets(JetCollection genJets);
    void setMuons(MuonCollection muons);
    void setMET(const METPointer met);
    void setHLTs(const boost::shared_ptr<std::vector<int> >);
    void setRunNumber(unsigned long number);
    void setEventNumber(unsigned long number);
    void setLocalEventNumber(unsigned long number);
    void setLumiBlock(unsigned long block);
    void setEventWeight(float weight);
    void setBeamScrapingVeto(bool isScraping);

    const VertexPointer PrimaryVertex() const;
    const VertexCollection& Vertices() const;
    const TrackCollection& Tracks() const;
    const MCParticleCollection& GenParticles() const;
    const ElectronCollection& Electrons() const;
    const ElectronCollection& GoodElectrons() const;
    const ElectronCollection& GoodIsolatedElectrons() const;
    const ElectronCollection& GoodPFIsolatedElectrons() const;
    const ElectronCollection& QCDElectrons() const;
    const JetCollection& Jets() const;
    const JetCollection& GenJets() const;
    const JetCollection& GoodJets() const;
    const JetCollection& GoodBJets() const;
    const MuonCollection& Muons() const;
    const MuonCollection& GoodMuons() const;
    const MuonCollection& GoodIsolatedMuons() const;
    const METPointer MET() const;
    const ElectronPointer MostIsolatedElectron(bool usePFIso) const;
    const ElectronPointer MostIsolatedElectron() const;
    const ElectronPointer MostPFIsolatedElectron() const;
    unsigned long runnumber() const;
    unsigned long eventnumber() const;
    unsigned long localnumber() const;
    unsigned long lumiblock() const;
    float weight() const;
    void inspect() const;
    bool HLT(HLTriggers::value trigger) const;
    static bool useCustomConversionTagger;
    static bool usePFIsolation;

private:
    void selectElectronsByQuality();
    void cleanGoodJets();
    void cleanGoodJetsAgainstIsolatedElectrons();
    void cleanGoodJetsAgainstMostIsolatedElectron();
    void selectGoodJets();
    void selectMuonsByQuality();
};

}

#endif /* EVENT_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/TopPairEventCandidate.h
//***********************************************************************


/*
 * TopPairEventCandidate.h
 *
 *  Created on: 9 Jul 2010
 *      Author: kreczko
 */

#ifndef TOPPAIREVENTCANDIDATE_H_
#define TOPPAIREVENTCANDIDATE_H_

#include <boost/shared_ptr.hpp>

#include "Event.h"
#include "ReconstructionRules/BasicRule.h"
#include "RecoObjects/Particle.h"
#include "RecoObjects/Electron.h"
#include "RecoObjects/Jet.h"
#include "Taggers/ConversionTagger.h"
#include "TtbarHypothesis.h"

namespace BAT {

namespace NeutrinoSelectionCriterion {
enum value {
    pzClosestToLepton,
    mostCentral,
    pzClosestToLeptonOrMostcentralIfAbove300,
    largestValueOfCosine,
    chi2,
    TopMassDifference
};
}

namespace TTbarReconstructionCriterion {
enum value {
  TopMassDifference,
  chi2
};
}

namespace TTbarEPlusJetsSelection {
enum Step {
    FilterOutScraping,
    HighLevelTrigger,
    GoodPrimaryvertex,
    OneIsolatedElectron,
    LooseMuonVeto,
    Zveto,
    ConversionRejection,
    ConversionFinder,
    AtLeastOneGoodJets,
    AtLeastTwoGoodJets,
    AtLeastThreeGoodJets,
    AtLeastFourGoodJets,
    NUMBER_OF_SELECTION_STEPS
};

const std::string StringSteps[NUMBER_OF_SELECTION_STEPS] = {
        "Scraping Filter",
        "High Level Trigger",
        "good primary vertex",
        "exactly one isolated electron",
        "loose muon veto",
        "Z veto",
        "Conversion veto (missing hits)",
        "Conversion finder (partner track)",
        ">= 1 jets",
        ">= 2 jets",
        ">= 3 jets",
        ">= 4 jets" };
}

struct ReconstructionException: public std::exception {
    TString msg;
    ReconstructionException(TString message) :
        msg(message) {
    }
    ~ReconstructionException() throw () {
    }

    const char* what() const throw () {
        return msg;
    }
};

class TopPairEventCandidate: public Event {

protected:
    static double const matched_angle;// = 0.945666;
    static double const matched_angle_sigma;// = 0.311091;
    static double const matched_leptonic_top_mass;// = 178.377;
    static double const matched_leptonic_top_mass_sigma;// = 31.050;
    static double const matched_hadronic_W_mass;// = 89.9153;
    static double const matched_hadronic_W_mass_sigma;// = 13.8711;
    static double const matched_hadronic_top_mass;// = 182.191;
    static double const matched_hadronic_top_mass_sigma;// = 22.1484;
    static double const matched_ptratio;// = 0.18552;
    static double const matched_ptratio_sigma;// = 0.401973;
    static double const matched_pt_ttbarSystem;// = 0.0760939;
    static double const matched_pt_ttbarSystem_sigma;// = 0.0700391;
    static double const matched_HTSystem;// = 1;
    static double const matched_HTSystem_sigma;// = 0.1;
    static double const W_mass;

    ElectronPointer electronFromW;
    JetPointer leptonicBJet, hadronicBJet, jet1FromW, jet2FromW;
    ParticlePointer neutrino1, neutrino2, leptonicW1, leptonicW2, hadronicW, leptonicTop1, leptonicTop2, hadronicTop,
            ttbarResonance;
    unsigned short selectedNeutrino, currentSelectedNeutrino, hadronicBIndex, leptonicBIndex, jet1FromWIndex,
            jet2FromWIndex;
    bool doneReconstruction;
    ConversionTaggerPointer conversionTagger;
    bool doneConversionTagging;
    std::vector<TtbarHypothesisPointer> solutions;
    compare_totalChi2 compareSolutions;
public:
    static NeutrinoSelectionCriterion::value usedNeutrinoSelection;
    static TTbarReconstructionCriterion::value usedTTbarReconstruction;
    TopPairEventCandidate();
    TopPairEventCandidate(const Event& event);
    virtual ~TopPairEventCandidate();

    virtual const JetPointer getLeptonicBJet() const;
    virtual const JetPointer getHadronicBJet() const;
    virtual const JetPointer getJet1FromHadronicW() const;
    virtual const JetPointer getJet2FromHadronicW() const;
    virtual const ElectronPointer getElectronFromWDecay() const;
    virtual const ParticlePointer getNeutrinoFromWDecay() const;
    virtual const ParticlePointer getLeptonicW() const;
    // virtual const ParticlePointer getHadronicW() const;
    virtual const ParticlePointer getLeptonicTop() const;
    virtual const ParticlePointer getHadronicTop() const;
    virtual const ParticlePointer getResonance() const;

    virtual bool passesSelectionStep(TTbarEPlusJetsSelection::Step step) const;
    virtual bool passesSelectionStepUpTo(TTbarEPlusJetsSelection::Step upToStep) const;
    virtual bool passesNMinus1(TTbarEPlusJetsSelection::Step omittedStep) const;
    virtual bool passesRelIsoSelection() const;
    virtual bool passesRelIsoControlSelection() const;
    virtual bool passesPFIsoSelection() const;
    virtual bool passesPFIsoControlSelection() const;
    virtual bool passesAntiIsolationSelection() const;

    virtual bool passesConversionSelection() const;

    virtual bool passesScrapingFilter() const;
    virtual bool passesHighLevelTrigger() const;
    virtual bool hasOneGoodPrimaryVertex() const;
    virtual bool hasOnlyOneGoodIsolatedElectron() const;
    virtual bool isolatedElectronDoesNotComeFromConversion() const;
    virtual bool isolatedElectronNotTaggedAsFromConversion() const;
    virtual bool hasNoIsolatedMuon() const;

    virtual bool hasAtLeastOneGoodJet() const;
    virtual bool hasAtLeastTwoGoodJets() const;
    virtual bool hasAtLeastThreeGoodJets() const;
    virtual bool hasAtLeastFourGoodJets() const;

    virtual bool isNotAZBosonEvent() const;
    virtual bool passesFullTTbarEPlusJetSelection() const;
    // virtual bool hasIsolatedElectronInBarrelRegion() const;

    virtual void reconstructTTbar(ElectronPointer electron);
    // virtual void reconstructUsingSubjets();
    // virtual void reconstructUsingMCTruth();
    void reconstruct(const Rule rule, const ElectronPointer electron);

    virtual double calculateTopMassDifference(unsigned short neutrinoSolution) const;
    virtual double getLeptonicChi2(unsigned short neutrinoSolution) const;
    virtual double getLeptonicChi2(double topMass, double angle) const;
    virtual double getHadronicChi2() const;
    virtual double getGlobalChi2(unsigned short neutrinoSolution) const;
    virtual double getTotalChi2(unsigned short neutrinoSolution) const;
    virtual double getTotalChi2();

    virtual double M3() const;
    virtual double mttbar() const;
    virtual double sumPt() const;
    virtual double HT(unsigned short jetLimit) const;
    virtual double fullHT() const;
    virtual double transverseWmass(const ElectronPointer electron) const;
    virtual double HTSystem() const;
    virtual double PtRatio() const;
    virtual double PtTtbarSystem(unsigned short neutrinoSolution) const;
    virtual const boost::array<double, 2> computeNeutrinoPz();
    virtual void reconstructNeutrinos();
    // virtual bool hasNextJetCombination();
    // virtual void selectNextJetCombination();
    virtual void inspectReconstructedEvent() const;
    // virtual unsigned int NJet() const;
    virtual const std::vector<TtbarHypothesisPointer>& Solutions() const;

protected:
    void throwExpeptionIfNotReconstructed() const;
    virtual void selectNeutrinoSolution();
    virtual void fillHypotheses();
    virtual const TtbarHypothesisPointer fillHypothesis(unsigned short int neutrinoSolution);

};

}

#endif /* TOPPAIREVENTCANDIDATE_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/TtbarHypothesis.h
//***********************************************************************


/*
 * TTbarHypothesis.h
 *
 *  Created on: Dec 4, 2010
 *      Author: lkreczko
 */

#ifndef TTBARHYPOTHESIS_H_
#define TTBARHYPOTHESIS_H_
#include "RecoObjects/Electron.h"
#include "RecoObjects/Jet.h"
#include "RecoObjects/MET.h"
#include "RecoObjects/Particle.h"

namespace BAT {
class TtbarHypothesis {
public:
  TtbarHypothesis();
  virtual ~TtbarHypothesis();
  double totalChi2, leptonicChi2, hadronicChi2, globalChi2, disc;
  ParticlePointer hadronicTop, leptonicTop, leptonicW, hadronicW, resonance, neutrinoFromW;
  JetPointer leptonicBjet, hadronicBJet, jet1FromW, jet2FromW;
  ElectronPointer electronFromW;
  METPointer met;

  double M3() const;

  bool operator==(const TtbarHypothesis& hyp) const;
  bool operator<(const TtbarHypothesis& hyp) const;

};

typedef boost::shared_ptr<TtbarHypothesis> TtbarHypothesisPointer;

struct compare_totalChi2 {
    bool operator ()(TtbarHypothesisPointer lhs, TtbarHypothesisPointer rhs) {
        return lhs->totalChi2 < rhs->totalChi2;
    }

    bool operator ()(TtbarHypothesis lhs, TtbarHypothesis rhs) {
        return lhs.totalChi2 < rhs.totalChi2;
    }
};

struct compare_disc {
    bool operator ()(TtbarHypothesisPointer lhs, TtbarHypothesisPointer rhs) {
        return lhs->disc <= rhs->disc;
    }

    bool operator ()(TtbarHypothesis lhs, TtbarHypothesis rhs) {
        return lhs.disc <= rhs.disc;
    }
};
} // namespace BAT

#endif /* TTBARHYPOTHESIS_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/DataTypes.h
//***********************************************************************


/*
 * Enumerators.h
 *
 *  Created on: Jun 30, 2010
 *      Author: lkreczko
 */

#ifndef ENUMERATORS_H_
#define ENUMERATORS_H_
#include <string>
#include <boost/array.hpp>

namespace BAT {
namespace DataType {
enum value {
    DATA,
    ttbar,
    Wjets,
    Zjets,
    QCD_BCtoE_Pt20to30,
    QCD_BCtoE_Pt30to80,
    QCD_BCtoE_Pt80to170,
    QCD_EMEnriched_Pt20to30,
    QCD_EMEnriched_Pt30to80,
    QCD_EMEnriched_Pt80to170,//10
    PhotonJets_Pt40to100,
    PhotonJets_Pt100to200,
    PhotonJets_Pt200toInf,
    VQQ,
    singleTop_And_W,
    singleTopTChannel,
    singleTopSChannel,
    Zprime_M500GeV_W5GeV,
    Zprime_M500GeV_W50GeV,
    Zprime_M750GeV_W7500MeV,//20
    Zprime_M1TeV_W10GeV,
    Zprime_M1TeV_W100GeV,
    Zprime_M1250GeV_W12500MeV,
    Zprime_M1500GeV_W15GeV,
    Zprime_M1500GeV_W150GeV,
    Zprime_M2TeV_W20GeV,
    Zprime_M2TeV_W200GeV,
    Zprime_M3TeV_W30GeV,
    Zprime_M3TeV_W300GeV,
    Zprime_M4TeV_W40GeV,//30
    Zprime_M4TeV_W400GeV,
    NUMBER_OF_DATA_TYPES
};

const boost::array<std::string, DataType::NUMBER_OF_DATA_TYPES> names = { {
        "Run",
        "TTJet",
        "WJetsToLNu",
        "DYJetsToLL",
        "QCD_Pt-20to30_BCtoE",
        "QCD_Pt-30to80_BCtoE",
        "QCD_Pt-80to170_BCtoE",
        "QCD_Pt-20to30_EMEnriched",
        "QCD_Pt-30to80_EMEnriched",
        "QCD_Pt-80to170_EMEnriched",//10
        "GJets_TuneD6T_HT-40To100",
        "GJets_TuneD6T_HT-100To200",
        "GJets_TuneD6T_HT-200",
        "VqqJets",
        "TToBLNu_TuneZ2_tW-channel",
        "TToBLNu_TuneZ2_t-channel",
        "TToBLNu_TuneZ2_s-channel",
        "Zprime_M500GeV_W5GeV",
        "Zprime_M500GeV_W50GeV",
        "Zprime_M750GeV_W7500MeV",//20
        "Zprime_M1000GeV_W10GeV",
        "Zprime_M1000GeV_W100GeV",
        "Zprime_M1250GeV_W12500MeV",
        "Zprime_M1500GeV_W15GeV",
        "Zprime_M1500GeV_W150GeV",
        "Zprime_M2000GeV_W20GeV",
        "Zprime_M2000GeV_W200GeV",
        "Zprime_M3000GeV_W30GeV",
        "Zprime_M3000GeV_W300GeV",
        "Zprime_M4000GeV_W40GeV",//30
        "Zprime_M4000GeV_W400GeV" } };
}

}

#endif /* ENUMERATORS_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/Printers/EventTablePrinter.h
//***********************************************************************


/*
 * EventPrinter.h
 *
 *  Created on: 22 Aug 2010
 *      Author: kreczko
 */

#ifndef EVENTTABLEPRINTER_H_
#define EVENTTABLEPRINTER_H_
#include "../EventCounter.h"

namespace BAT {

namespace EventTablePrinter {
extern void printCutFlowCSVTable(const Counter& cutFlow);
extern void printCutFlowLatexTable(const Counter& cutFlow);
extern void printUnweightedCutFlowLatexTable(const Counter& cutFlow);
}
}
#endif /* EVENTPRINTER_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/Printers/EventContentPrinter.h
//***********************************************************************


/*
 * EventPrinter.h
 *
 *  Created on: 22 Aug 2010
 *      Author: kreczko
 */

#ifndef EventContentPrinter_H_
#define EventContentPrinter_H_
#include "../RecoObjects/MCParticle.h"
#include "../RecoObjects/Particle.h"
#include "../RecoObjects/Electron.h"
#include "../RecoObjects/Jet.h"

namespace BAT {

namespace EventContentPrinter {
    extern void printJets(const JetCollection jets);
    extern void printElectrons(const ElectronCollection electrons);

    extern void printJet(const JetPointer jet);
    extern void printPFJetExtra(const JetPointer jet);
    extern void printElectron(const ElectronPointer electron);
    extern void printParticle(const ParticlePointer particle);
    extern void printGenParticle(const MCParticlePointer genParticle);
    extern void printCutFlowTable();
    extern void printWeightedCutFlowTable();
}
}
#endif /* EVENTPRINTER_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/OnlyForTests/DummyTTbarEvent.h
//***********************************************************************


/*
 * DummyTTbarEvent.h
 *
 *  Created on: 25 Aug 2010
 *      Author: kreczko
 */

#ifndef DUMMYTTBAREVENT_H_
#define DUMMYTTBAREVENT_H_

#include "../TopPairEventCandidate.h"

namespace BAT {

class DummyTTbarEvent: public TopPairEventCandidate {
public:
    DummyTTbarEvent();
    virtual ~DummyTTbarEvent();
    void setElectronFromW(const ElectronPointer electron);
    bool passScraping, passHLT, passPV, passElectronCut, passConversion, passConversionPartnerTrack, passesMuon,
            passes1JetCut, passes2JetCut, passes3JetCut, passes4JetCut, passesZveto, useCustomReturnValues;

    bool passesScrapingFilter() const;
    bool passesHighLevelTrigger() const;
    bool hasOneGoodPrimaryVertex() const;
    bool hasOnlyOneGoodIsolatedElectron() const;
    bool isolatedElectronDoesNotComeFromConversion() const;
    bool isolatedElectronNotTaggedAsFromConversion() const;
    bool hasNoIsolatedMuon() const;

    bool hasAtLeastOneGoodJet() const;
    bool hasAtLeastTwoGoodJets() const;
    bool hasAtLeastThreeGoodJets() const;
    bool hasAtLeastFourGoodJets() const;

    bool isNotAZBosonEvent() const;
    bool passesNMinus1(TTbarEPlusJetsSelection::Step omittedStep) const;
    bool passesSelectionStep(enum TTbarEPlusJetsSelection::Step step) const;
};

}

#endif /* DUMMYTTBAREVENT_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/TopPairCandidateTutorial.h
//***********************************************************************


/*
 * TopPairCandidateTutorial.h
 *
 */

#ifndef TOPPAIRCANDIDATETUTORIAL_H_
#define TOPPAIRCANDIDATETUTORIAL_H_

#include <boost/shared_ptr.hpp>
#include "Event.h"
#include "RecoObjects/Particle.h"
#include "RecoObjects/Electron.h"
#include "RecoObjects/Jet.h"
#include "Taggers/ConversionTagger.h"
#include "TtbarHypothesis.h"
#include "TopPairEventCandidate.h"


namespace BAT {


class TopPairCandidateTutorial: public Event {

protected:
    static double const matched_angle;// = 0.945666;
    static double const matched_angle_sigma;// = 0.311091;
    static double const matched_leptonic_top_mass;// = 178.377;
    static double const matched_leptonic_top_mass_sigma;// = 31.050;
    static double const matched_hadronic_W_mass;// = 89.9153;
    static double const matched_hadronic_W_mass_sigma;// = 13.8711;
    static double const matched_hadronic_top_mass;// = 182.191;
    static double const matched_hadronic_top_mass_sigma;// = 22.1484;
    static double const matched_ptratio;// = 0.18552;
    static double const matched_ptratio_sigma;// = 0.401973;
    static double const matched_pt_ttbarSystem;// = 0.0760939;
    static double const matched_pt_ttbarSystem_sigma;// = 0.0700391;
    static double const matched_HTSystem;// = 1;
    static double const matched_HTSystem_sigma;// = 0.1;
    static double const W_mass;

    ElectronPointer electronFromW;
    JetPointer leptonicBJet, hadronicBJet, jet1FromW, jet2FromW;
    ParticlePointer neutrino1, neutrino2, leptonicW1, leptonicW2, hadronicW, leptonicTop1, leptonicTop2, hadronicTop,
            ttbarResonance;
    unsigned short selectedNeutrino, currentSelectedNeutrino, hadronicBIndex, leptonicBIndex, jet1FromWIndex,
            jet2FromWIndex;
    bool doneReconstruction;
    ConversionTaggerPointer conversionTagger;
    bool doneConversionTagging;
    std::vector<TtbarHypothesisPointer> solutions;
    compare_totalChi2 compareSolutions;
public:
    static NeutrinoSelectionCriterion::value usedNeutrinoSelection;
    static TTbarReconstructionCriterion::value usedTTbarReconstruction;
    TopPairCandidateTutorial();
    TopPairCandidateTutorial(const Event& event);
    virtual ~TopPairCandidateTutorial();

    virtual const JetPointer getLeptonicBJet() const;
    virtual const JetPointer getHadronicBJet() const;
    virtual const JetPointer getJet1FromHadronicW() const;
    virtual const JetPointer getJet2FromHadronicW() const;
    virtual const ElectronPointer getElectronFromWDecay() const;
    virtual const ParticlePointer getNeutrinoFromWDecay() const;
    virtual const ParticlePointer getLeptonicW() const;
    // virtual const ParticlePointer getHadronicW() const;
    virtual const ParticlePointer getLeptonicTop() const;
    virtual const ParticlePointer getHadronicTop() const;
    virtual const ParticlePointer getResonance() const;

    virtual bool passesSelectionStep(TTbarEPlusJetsSelection::Step step) const;
    virtual bool passesSelectionStepUpTo(TTbarEPlusJetsSelection::Step upToStep) const;
    virtual bool passesNMinus1(TTbarEPlusJetsSelection::Step omittedStep) const;
    virtual bool passesRelIsoSelection() const;
    virtual bool passesRelIsoControlSelection() const;
    virtual bool passesPFIsoSelection() const;
    virtual bool passesPFIsoControlSelection() const;
    virtual bool passesAntiIsolationSelection() const;

    virtual bool passesConversionSelection() const;

    virtual bool passesScrapingFilter() const;
    virtual bool passesHighLevelTrigger() const;
    virtual bool hasOneGoodPrimaryVertex() const;
    virtual bool hasOnlyOneGoodIsolatedElectron() const;
    virtual bool isolatedElectronDoesNotComeFromConversion() const;
    virtual bool isolatedElectronNotTaggedAsFromConversion() const;
    virtual bool hasNoIsolatedMuon() const;

    virtual bool hasAtLeastOneGoodJet() const;
    virtual bool hasAtLeastTwoGoodJets() const;
    virtual bool hasAtLeastThreeGoodJets() const;
    virtual bool hasAtLeastFourGoodJets() const;

    virtual bool isNotAZBosonEvent() const;
    virtual bool passesFullTTbarEPlusJetSelection() const;
    // virtual bool hasIsolatedElectronInBarrelRegion() const;

    virtual void reconstructTTbar(ElectronPointer electron);
    // virtual void reconstructUsingSubjets();
    // virtual void reconstructUsingMCTruth();

    virtual double calculateTopMassDifference(unsigned short neutrinoSolution) const;
    virtual double getLeptonicChi2(unsigned short neutrinoSolution) const;
    virtual double getLeptonicChi2(double topMass, double angle) const;
    virtual double getHadronicChi2() const;
    virtual double getGlobalChi2(unsigned short neutrinoSolution) const;
    virtual double getTotalChi2(unsigned short neutrinoSolution) const;
    virtual double getTotalChi2();

    virtual double M3() const;
    virtual double mttbar() const;
    virtual double sumPt() const;
    virtual double HT(unsigned short jetLimit) const;
    virtual double fullHT() const;
    virtual double transverseWmass(const ElectronPointer electron) const;
    virtual double HTSystem() const;
    virtual double PtRatio() const;
    virtual double PtTtbarSystem(unsigned short neutrinoSolution) const;
    virtual const boost::array<double, 2> computeNeutrinoPz();
    virtual void reconstructNeutrinos();
    // virtual bool hasNextJetCombination();
    // virtual void selectNextJetCombination();
    virtual void inspectReconstructedEvent() const;
    // virtual unsigned int NJet() const;
    virtual const std::vector<TtbarHypothesisPointer>& Solutions() const;

protected:
    void throwExpeptionIfNotReconstructed() const;
    virtual void selectNeutrinoSolution();
    virtual void fillHypotheses();
    virtual const TtbarHypothesisPointer fillHypothesis(unsigned short int neutrinoSolution);

};

}

#endif /* TOPPAIRCANDIDATETUTORIAL_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/HistHelpers/StringOperations.h
//***********************************************************************


/*
 * StringOperations.h
 *
 *  Created on: 11 Aug 2010
 *      Author: kreczko
 */

#ifndef STRINGOPERATIONS_H_
#define STRINGOPERATIONS_H_
#include <string>
#include <vector>
namespace BAT {
using namespace std;

extern vector<string> getDirectoriesFromPath(string path);
}

#endif /* STRINGOPERATIONS_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/HistHelpers/HistogramManager.h
//***********************************************************************


/*
 * HistogramManager.h
 *
 *  Created on: 4 Jul 2010
 *      Author: kreczko
 */

#ifndef HISTOGRAMMANAGER_H_
#define HISTOGRAMMANAGER_H_
#include "THCollection.h"
#include "TH1D.h"
#include "TH2D.h"
#include "../../interface/DataTypes.h"
#include <boost/shared_ptr.hpp>
#include <boost/array.hpp>
#include <boost/multi_array.hpp>
#include "TFile.h"
#include <string>

namespace BAT {

namespace JetBin {
enum value {
    NoJet,
    OneJet,
    TwoJets,
    ThreeJets,
    FourOrMoreJets,
    NUMBER_OF_JET_BINS
};

const boost::array<std::string, JetBin::NUMBER_OF_JET_BINS> names = {
        { "0jet", "1jet", "2jets", "3jets", "4orMoreJets"
        } };
}

namespace JetBinSummed {
enum value {
    allJet,
    OneOrMoreJets,
    TwoOrMoreJets,
    ThreeOrMoreJets,
    NUMBER_OF_SUMMED_JET_BINS
};

const boost::array<std::string, JetBinSummed::NUMBER_OF_SUMMED_JET_BINS> names = { {
        "0orMoreJets",
        "1orMoreJets",
        "2orMoreJets",
        "3orMoreJets" } };
}

namespace BJetBin {
enum value {
    NoBtag,
    OneBTag,
    TwoBtags,
    ThreeBtags,
    FourOrMoreBTags,
    NUMBER_OF_BJET_BINS
};

const boost::array<std::string, BJetBin::NUMBER_OF_BJET_BINS> names = { {
        "0btag",
        "1btag",
        "2btags",
        "3btags",
        "4orMoreBtags" } };
}

namespace BJetBinSummed {
enum value {
    allBtags,
    OneOrMoreBTags,
    TwoOrMoreBTags,
    ThreeOrMoreBTags,
    NUMBER_OF_SUMMED_BJET_BINS
};

const boost::array<std::string, BJetBinSummed::NUMBER_OF_SUMMED_BJET_BINS> names = { {
        "0orMoreBtag",
        "1orMoreBtag",
        "2orMoreBtags",
        "3orMoreBtags" } };
}

typedef unsigned short ushort;
class HistogramManager {
public:
    HistogramManager();
    virtual ~HistogramManager();
    void createAllHistograms();
    void addH1D(std::string name, std::string title, unsigned int nBins, float xmin, float xmax);
    void addH1D_JetBinned(std::string name, std::string title, unsigned int nBins, float xmin, float xmax);
    void addH1D_BJetBinned(std::string name, std::string title, unsigned int nBins, float xmin, float xmax);
    void addH2D_BJetBinned(std::string name, std::string title, unsigned int nXBins, float xmin, float xmax,
            unsigned int nYBins, float ymin, float ymax);

    void addH2D(std::string name, std::string title, unsigned int nXBins, float xmin, float xmax, unsigned int nYBins,
            float ymin, float ymax);

    void setCurrentDataType(DataType::value type);
    void setCurrentJetBin(unsigned int jetbin);
    void setCurrentBJetBin(unsigned int jetbin);
    void setCurrentLumi(float lumi);
    void prepareForSeenDataTypes(const boost::array<bool, DataType::NUMBER_OF_DATA_TYPES>& seenDataTypes);

    boost::shared_ptr<TH1> operator[](std::string);
    boost::shared_ptr<TH1> H1D(std::string);
    boost::shared_ptr<TH1> H1D_JetBinned(std::string);
    boost::shared_ptr<TH1> H1D_BJetBinned(std::string);
    boost::shared_ptr<TH2> operator()(std::string);
    boost::shared_ptr<TH2> H2D(std::string);
    boost::shared_ptr<TH2> H2D_JetBinned(std::string);
    boost::shared_ptr<TH2> H2D_BJetBinned(std::string);

    void writeToDisk();
private:
    boost::multi_array<TH1CollectionRef, 2> jetBinned1DHists;
    std::vector<std::string> jetBinned1DHistNames;
    boost::multi_array<TH2CollectionRef, 2> jetBinned2DHists;
    std::vector<std::string> jetBinned2DHistNames;
    boost::multi_array<TH1CollectionRef, 2> bJetBinned1DHists;
    std::vector<std::string> bJetBinned1DHistNames;
    boost::multi_array<TH2CollectionRef, 2> bJetBinned2DHists;
    std::vector<std::string> bJetBinned2DHistNames;
    boost::array<bool, DataType::NUMBER_OF_DATA_TYPES> seenDataTypes;
    boost::array<boost::shared_ptr<TFile>, DataType::NUMBER_OF_DATA_TYPES> histFiles;
    boost::array<TH1CollectionRef, DataType::NUMBER_OF_DATA_TYPES> collection;// move to array of DataTypes
    std::vector<std::string> collection1DHistNames;
    boost::array<TH2CollectionRef, DataType::NUMBER_OF_DATA_TYPES> collection2D;
    std::vector<std::string> collection2DHistNames;
    DataType::value currentDataType;
    unsigned int currentJetbin;
    unsigned int currentBJetbin;
    float currentIntegratedLumi;

    const std::string assembleFilename(DataType::value) const;
    void createSummedHistograms(DataType::value);
    void createJetSummedHistograms(DataType::value);
    void createBJetSummedHistograms(DataType::value);
};

}

#endif /* HISTOGRAMMANAGER_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/HistHelpers/THCollection.h
//***********************************************************************


/*
 * THCollection.h
 *
 *  Created on: 9 Aug 2010
 *      Author: kreczko
 */

#ifndef THCOLLECTION_H_
#define THCOLLECTION_H_
#include <string>

#include "TFile.h"
#include "TDirectory.h"
#include "TH1.h"
#include "TH2.h"

#include <boost/unordered_map.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/foreach.hpp>
#include <iostream>
#include "StringOperations.h"

using namespace boost;
namespace BAT {

template<class histType>
class THCollection {
    typedef shared_ptr<histType> histPointer;
    typedef unordered_map<std::string, histPointer> map;

protected:
    boost::shared_ptr<TFile> histogramFile;
    std::string path;
    std::vector<std::string> directories;
    map histMap;
    std::string prefix, suffix;
public:
    //    THCollection() :
    //        histogramFile(), directories(), histMap() {
    //
    //    }

    THCollection(std::string virtualPath = "") :
        histogramFile(),
        path(virtualPath),
        directories(getDirectoriesFromPath(path)),
        histMap(),
        prefix(""),
        suffix("") {

    }

    ~THCollection() {

    }

    void add(std::string name, std::string title, unsigned int numberOfBins, float xmin, float xmax);
    void add(std::string name, std::string title, unsigned int numberOfXBins, float xmin, float xmax,
            unsigned int numberOfYBins, float ymin, float ymax);

    void add(std::string name, boost::shared_ptr<histType> hist){
        histMap[name] = hist;
    }

    boost::shared_ptr<histType> get(std::string name) {
        histPointer histp = histMap[name];
        if (histp == NULL)
          cout << "\n **** Histogram " << name << " not defined. **** \n\n";
        return histMap[name];
    }

    unsigned int size() const {
        return histMap.size();
    }

    void writeToFile(boost::shared_ptr<TFile> histFile) {
        histogramFile = histFile;
        histogramFile->cd();
        writeDirectories();
        histogramFile->Cd(path.c_str());
        writeHistograms();
    }

    void setPrefix(std::string pre){
        prefix = pre;
    }

    void setSuffix(std::string suf){
        suffix = suf;
    }

    map getAllHistograms(){
        return histMap;
    }

private:

    void writeDirectories() {
        std::string currentPath = "";

        for (unsigned short index = 0; index < directories.size(); ++index) {
            const std::string dir = directories.at(index);

            if (index == 0) {
                histogramFile->mkdir(dir.c_str());
                currentPath = dir;
            } else {
                TDirectory* currentDir = (TDirectory*) histogramFile->Get(currentPath.c_str());
                assert(currentDir != 0);
                currentDir->mkdir(dir.c_str());
                currentPath += "/" + dir;
            }
        }
    }
    void writeHistograms() {
        for (typename map::const_iterator iter = histMap.begin(); iter != histMap.end(); ++iter) {
            std::string newName(iter->second->GetName());
            if (prefix != "") {
                newName = prefix + "_" + newName;
            }
            if (suffix != "")
                newName = newName + "_" + suffix;
            iter->second->Write(newName.c_str());
        }
    }

};

typedef THCollection<TH1> TH1Collection;
typedef THCollection<TH2> TH2Collection;
typedef boost::shared_ptr<THCollection<TH1> > TH1CollectionRef;
typedef boost::shared_ptr<THCollection<TH2> > TH2CollectionRef;

}

#endif /* THCOLLECTION_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/HighLevelTriggers.h
//***********************************************************************


/*
 * HighLevelTriggers.h
 *
 *  Created on: 17 Mar 2011
 *      Author: kreczko
 */

#ifndef HIGHLEVELTRIGGERS_H_
#define HIGHLEVELTRIGGERS_H_

namespace HLTriggers{
enum value{
//2010 data RunA + RunB
    HLT_Ele10_LW_L1R, //0
    HLT_Ele15_SW_L1R, //1
    HLT_Ele15_SW_CaloEleId_L1R, //2
    HLT_Ele17_SW_CaloEleId_L1R, //3
    HLT_Ele17_SW_EleId_L1R, //4
    HLT_Ele17_SW_LooseEleId_L1R, //5
    HLT_Ele17_SW_TightEleIdIsol_L1R_v1, //6
    HLT_Ele17_SW_TightEleId_L1R, //7
    HLT_Ele17_SW_TighterEleIdIsol_L1R_v1, //8
    HLT_Ele17_SW_TighterEleId_L1R_v1, //9
    HLT_Ele22_SW_TighterEleId_L1R_v2, //10
    HLT_Ele22_SW_TighterEleId_L1R_v3, //11
    HLT_Ele27_SW_TightCaloEleIdTrack_L1R_v1, //12
    //2011 data
    HLT_Ele25_CaloIdVT_TrkIdT_CentralDiJet30_v1, //13
    HLT_Ele25_CaloIdVT_TrkIdT_CentralJet30_v1, //14
    HLT_Ele25_CaloIdVT_TrkIdT_CentralJet40_BTagIP_v1, //15
    HLT_Ele25_CaloIdVT_TrkIdT_CentralTriJet30_v1, //16
    HLT_Ele25_CaloIdVT_TrkIdT_CentralDiJet30_v2, //17
    HLT_Ele25_CaloIdVT_TrkIdT_CentralJet30_v2, //18
    HLT_Ele25_CaloIdVT_TrkIdT_CentralJet40_BTagIP_v2, //19
    HLT_Ele25_CaloIdVT_TrkIdT_CentralTriJet30_v2, //20
    //additional triggers to recover boosted top
    HLT_Ele10_CaloIdT_CaloIsoVL_TrkIdT_TrkIsoVL_HT200_v2, //21
    HLT_Ele27_CaloIdVT_CaloIsoT_TrkIdT_TrkIsoT_v1, //22
    HLT_Ele45_CaloIdVT_TrkIdT_v1, //23
    HLT_Ele10_CaloIdT_CaloIsoVL_TrkIdT_TrkIsoVL_HT200_v3, //24
    HLT_Ele27_CaloIdVT_CaloIsoT_TrkIdT_TrkIsoT_v2, //25
    HLT_Ele45_CaloIdVT_TrkIdT_v2 //26
};
}
#endif /* HIGHLEVELTRIGGERS_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/RecoObjects/Particle.h
//***********************************************************************


/*
 * Particle.h
 *
 *  Created on: 2 Jul 2010
 *      Author: kreczko
 */

#ifndef PARTICLE_H_
#define PARTICLE_H_
#include "TLorentzVector.h"
#include <vector>
#include <string>
#include <math.h>
#include <boost/shared_ptr.hpp>

typedef TLorentzVector FourVector;

namespace BAT {
class Particle;

typedef boost::shared_ptr<Particle> ParticlePointer;
typedef std::vector<ParticlePointer> ParticleCollection;


class Particle {
public:
  Particle();
  Particle(const Particle& particle);
  Particle(float energy, float px, float py, float pz);
  virtual ~Particle();
  const Particle operator+(const Particle &other) const;
  Particle & operator=(const Particle &rightHandSide);
  float mass() const;
  float d0() const;
  float d0_wrtBeamSpot() const;
  float energy() const;
  float et() const;
  float px() const;
  float py() const;
  float pz() const;
  float pt() const;
  float eta() const;
  float phi() const;
  float theta() const;
  float massFromEnergyAndMomentum() const;
  float charge() const;
  void setMass(float mass);
  void setD0(float d0);
  void setD0_wrtBeamSpot(float d0);
  void setCharge(float charge);
  const FourVector& getFourVector() const;
  void setFourVector(FourVector fourvector);
  unsigned short getClosest(const ParticleCollection& particles) const;

  bool isInBarrelRegion() const;
  bool isInCrack() const;
  bool isInEndCapRegion() const;
  const char* getEtaRegion() const;
  float relativePtTo(const ParticlePointer otherParticle) const;
  float deltaR(const ParticlePointer otherParticle) const;
  float deltaPhi(const ParticlePointer otherParticle) const;
  float deltaEta(const ParticlePointer otherParticle) const;
  bool isWithinDeltaR(float deltaR, const ParticlePointer particle) const;
  float invariantMass(const ParticlePointer otherParticle) const;
  float angle(const ParticlePointer otherParticle) const;

protected:
  float particleMass, particleCharge;
  float distanceFromInteractionPointInMicron;
  float distanceFromInteractionPointInMicron_wrt_to_BeamSpot;
  FourVector fourvector;

};

}

#endif /* PARTICLE_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/RecoObjects/MCParticle.h
//***********************************************************************


/*
 * MCParticle.h
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#ifndef MCPARTICLE_H_
#define MCPARTICLE_H_
#include "Particle.h"
#include "Jet.h"

namespace BAT {
class MCParticle;
typedef boost::shared_ptr<MCParticle> MCParticlePointer;
typedef std::vector<MCParticlePointer> MCParticleCollection;

class MCParticle: public Particle {
public:
  int pdgId() const;
  int motherIndex() const;
  int status() const;
  MCParticle();
  MCParticle(float energy, float px, float py, float pz);
  //MCParticle(int pdgId, float phi, float eta, float pt, float energy, int motherIndex, int status);
  virtual ~MCParticle();
  void setPdgId(int PdgId);
  void setMotherIndex(int MotherIndex);
  void setStatus(int Status);
  bool isQuark() const;
  bool isLepton() const;
  bool isNeutrino() const;
  unsigned short getClosestJetIndex(const JetCollection& jets) const;
protected:
  int particlePdgId;
  int particleMotherIndex;
  int particleStatus;
};

}

#endif /* MCPARTICLE_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/RecoObjects/Electron.h
//***********************************************************************


/*
 * Electron.h
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#ifndef ELECTRON_H_
#define ELECTRON_H_
#include "Particle.h"
#include <vector>
#include <string>
#include <boost/static_assert.hpp>
#include <boost/array.hpp>
#include <boost/shared_ptr.hpp>
#include "Jet.h"
#include "Track.h"

namespace BAT {

namespace ElectronAlgorithm {
enum value {
    Calo,
    ParticleFlow,
    NUMBER_OF_ELECTRONALGORITHMS
};

const boost::array<std::string, ElectronAlgorithm::NUMBER_OF_ELECTRONALGORITHMS> prefixes = { {
        "Electron",
        "PFElectron"  } };

const boost::array<std::string, ElectronAlgorithm::NUMBER_OF_ELECTRONALGORITHMS> names = { {
        "CaloElectron",
        "PFElectron"} };
}

namespace ElectronIsolation{
enum value {
    RelativeIsolation,
    ParticleFlowIsolation,
    NUMBER_OF_ELECTRONISOLATIONS
};
}

class Electron: public Particle {
public:

    Electron();
    Electron(float energy, float px, float py, float pz);
    virtual ~Electron();
    bool isGood(const float minEt = 30) const;
    bool isIsolated() const;
    bool isPFIsolated() const;
    bool isHEEPIsolated() const;
    bool isTaggedAsConversion(float maxDist, float maxDCotTheta) const;
    bool isFromConversion() const;
    bool isLoose() const;
    bool isQCDElectron(const float minEt = 30) const;

    ElectronAlgorithm::value algorithm() const;
    float ecalIsolation() const;
    float hcalIsolation() const;
    float trackerIsolation() const;
    float PFGammaIsolation() const;
    float PFChargedHadronIsolation() const;
    float PFNeutralHadronIsolation() const;
    float superClusterEta() const;
    float sigmaIEtaIEta() const;
    float dPhiIn() const;
    float dEtaIn() const;
    float HadOverEm() const;
    float HEEPet() const;
    float innerLayerMissingHits() const;
    float dCotThetaToClosestTrack() const;
    float distToClosestTrack() const;
    bool VBTF_W70_ElectronID() const;
    bool VBTF_W95_ElectronID() const;
    bool QCD_AntiID_W70() const;
    bool QCD_AntiID_W70_Barrel() const;
    bool QCD_AntiID_W70_Endcap() const;
    bool RobustLooseID() const;
    bool RobustTightID() const;
    unsigned short getClosestJetIndex(const JetCollection& jets) const;
    ElectronAlgorithm::value getUsedAlgorithm() const;
    const TrackPointer GSFTrack() const;
    int closestCTFTrackID() const;
    float shFracInnerLayer() const;
    float ZDistanceToPrimaryVertex() const;

    void setRobustLooseID(bool id);
    void setRobustTightID(bool id);

    void setSuperClusterEta(float eta);
    void setEcalIsolation(float isolation);
    void setHcalIsolation(float isolation);
    void setTrackerIsolation(float isolation);
    void setNumberOfMissingInnerLayerHits(float missingHits);
    void setUsedAlgorithm(ElectronAlgorithm::value algo);
    void setSigmaIEtaIEta(float sigma);
    void setDPhiIn(float dphi);
    void setDEtaIn(float deta);
    void setHadOverEm(float HoverE);
    void setGSFTrack(const TrackPointer track);
    void setClosestTrackID(const int trackID);
    void setSharedFractionInnerHits(float hits);
//    void setElectronVertexZPosition(float z);
    void setZDistanceToPrimaryVertex(float dist);
    void setDistToNextTrack(float dist);
    void setDCotThetaToNextTrack(float dCotTheta);
    void setPFGammaIsolation(float pfGammaIso);
    void setPFChargedHadronIsolation(float chargedHadronIso);
    void setPFNeutralHadronIsolation(float neutralHadronIso);

    float relativeIsolation() const;
    float pfIsolation() const;

    bool isInBarrelRegion() const;
    bool isInCrack() const;
    bool isInEndCapRegion() const;

//    float vz() const;

private:
    ElectronAlgorithm::value usedAlgorithm;
    bool robustLooseId, robustTightId;
    float superCluser_Eta;
    float ecal_Isolation, hcal_Isolation, tracker_Isolation;
    float innerLayerMissingHits_;
    //used for HEEP
    float sigma_IEtaIEta, dPhi_In, dEta_In, hadOverEm;
    TrackPointer gsfTrack;
    int closesTrackID;
    float sharedFractionInnerHits;
    float zDistanceToPrimaryVertex, dCotThetaToNextTrack, distToNextTrack;
    float PFGamma_Isolation, PFChargedHadron_Isolation, PFNeutralHadron_Isolation;

    bool getVBTF_W70_ElectronID_Barrel() const;
    bool getVBTF_W70_ElectronID_Endcap() const;
    bool getVBTF_W95_ElectronID_Barrel() const;
    bool getVBTF_W95_ElectronID_Endcap() const;

};

typedef boost::shared_ptr<Electron> ElectronPointer;
typedef std::vector<ElectronPointer> ElectronCollection;

}

#endif /* ELECTRON_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/RecoObjects/Photon.h
//***********************************************************************


/*
 * Photon.h
 *
 *  Created on: 2 Jul 2010
 *      Author: kreczko
 */

#ifndef PHOTON_H_
#define PHOTON_H_

#include "Particle.h"

namespace BAT {

class Photon: public BAT::Particle {
public:
  Photon();
  virtual ~Photon();
};

}

#endif /* PHOTON_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/RecoObjects/MET.h
//***********************************************************************


/*
 * MET.h
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#ifndef MET_H_
#define MET_H_
#include "Particle.h"
#include <boost/shared_ptr.hpp>
#include <string>
#include <boost/array.hpp>

namespace BAT {

namespace METAlgorithm {
enum value {
    Calo,
    tcMET,
    ParticleFlowMET,
    NUMBER_OF_METALGORITHMS
};

const boost::array<std::string, METAlgorithm::NUMBER_OF_METALGORITHMS> prefixes = { {
        "CaloMET",
        "TCMET",
        "PFMET"  } };

const boost::array<std::string, METAlgorithm::NUMBER_OF_METALGORITHMS> names = { {
        "CaloMET",
        "TCMET",
        "PFMET" } };
}

class MET: public Particle {
public:
  MET();
  MET(float ex, float ey);
  virtual ~MET();
  bool isGood() const;
  void setUsedAlgorithm(METAlgorithm::value algo);
  METAlgorithm::value getUsedAlgorithm() const;
private:
  METAlgorithm::value usedAlgorithm;
};

typedef boost::shared_ptr<MET> METPointer;

}

#endif /* MET_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/RecoObjects/Muon.h
//***********************************************************************


/*
 * Muon.h
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#ifndef MUON_H_
#define MUON_H_
#include "Particle.h"
#include <vector>
#include <string>
#include <boost/array.hpp>

namespace BAT {

namespace MuonAlgorithm {
enum value {
    Default,
    ParticleFlow,
    NUMBER_OF_MUONALGORITHMS
};

const boost::array<std::string, MuonAlgorithm::NUMBER_OF_MUONALGORITHMS> prefixes = { {
        "Muon",
        "PFMuon"  } };

const boost::array<std::string, MuonAlgorithm::NUMBER_OF_MUONALGORITHMS> names = { {
        "Muon",
        "PFMuon"} };
}


class Muon: public Particle {
public:
  Muon();
  Muon(float energy, float px, float py, float pz);
  virtual ~Muon();
  bool isGood() const;
  bool isIsolated() const;
  bool isGlobal() const;
  float ecalIsolation() const;
  float hcalIsolation() const;
  float trackerIsolation() const;
  float relativeIsolation() const;

  void makeGlobal(bool global);
  void setEcalIsolation(float isolation);
  void setHcalIsolation(float isolation);
  void setTrackerIsolation(float isolation);
private:
  bool is_Global;
  float ecal_Isolation, hcal_Isolation, tracker_Isolation;
};

typedef boost::shared_ptr<Muon> MuonPointer;
typedef std::vector<MuonPointer> MuonCollection;
}

#endif /* MUON_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/RecoObjects/Track.h
//***********************************************************************


/*
 * Track.h
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#ifndef TRACK_H_
#define TRACK_H_
#include "PseudoParticle.h"
#include <boost/shared_ptr.hpp>
#include <vector>

namespace BAT {
class Track;
typedef boost::shared_ptr<Track> TrackPointer;
typedef std::vector<TrackPointer> TrackCollection;

class Track : public PseudoParticle{
private:
    static const double BFIELD;
    bool highPurity;
public:
    Track();
    Track(const Track& other);
    Track(float phi, float eta, float pt, float theta);
    virtual ~Track();
    double curvature(double Bfield = BFIELD) const;
    double distance(const TrackPointer otherTrack, double Bfield = BFIELD) const;
    double deltaCotTheta(const TrackPointer otherTrack) const;
    double x(double Bfield = BFIELD) const;
    double y(double Bfield = BFIELD) const;
    double radius(double Bfield = BFIELD) const;
    void setHighPurity(bool isPure);
    bool isHighPurity() const;
};

}

#endif /* TRACK_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/RecoObjects/Jet.h
//***********************************************************************


/*
 * Jet.h
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#ifndef JET_H_
#define JET_H_
#include "Particle.h"
#include <vector>
#include <string>
#include <boost/array.hpp>

namespace BAT {

namespace BtagAlgorithm {
enum value {
    GenPartonFlavour,
    JetBProbabilityBTag,
    JetProbabilityBTag,
    SimpleSecondaryVertexHighEffBTag,
    SimpleSecondaryVertexHighPurBTag,
    TrackCountingHighEffBTag,
    TrackCountingHighPurBTag,
    NUMBER_OF_BTAGALGORITHMS
};

enum workingPoint {
    LOOSE, MEDIUM, TIGHT
};
}

namespace JetAlgorithm {
enum value {
    Calo_AntiKT_Cone05, JPT_AntiKt_ConeDR05, ParticleFlow, PF2PAT, NUMBER_OF_JETALGORITHMS
};
//for nTuple branch names
const boost::array<std::string, JetAlgorithm::NUMBER_OF_JETALGORITHMS> prefixes = { {
        "CaloJet",
        "",
        "PFJet",
        "PF2PATJet" } };

const boost::array<std::string, JetAlgorithm::NUMBER_OF_JETALGORITHMS> names = { {
        "CaloJets",
        "JPT",
        "PFJets",
        "PF2PATJets" } };
}

class Jet: public Particle {
public:

    Jet();
    Jet(const Particle& particle);
    Jet(float energy, float px, float py, float pz);
    virtual ~Jet();
    bool isGood() const;
    bool isBJet(BtagAlgorithm::value type = BtagAlgorithm::SimpleSecondaryVertexHighEffBTag,
            BtagAlgorithm::workingPoint wp = BtagAlgorithm::MEDIUM) const;
    JetAlgorithm::value getUsedAlgorithm() const;
    float emf() const;
    float n90Hits() const;
    float fHPD() const;
    float NOD() const;
    float CEF() const;
    float NHF() const;
    float NEF() const;
    float CHF() const;
    float NCH() const;

    void setUsedAlgorithm(JetAlgorithm::value algo);
    void setEMF(float emf);
    void setN90Hits(int n90Hits);
    void setFHPD(float fHPD);
    void setDiscriminatorForBtagType(float discriminator, BtagAlgorithm::value type);
    //  void setBtagForData(float btag);
    void setNOD(int nod);
    void setCEF(float cef);
    void setNHF(float nhf);
    void setNEF(float nef);
    void setCHF(float chf);
    void setNCH(float nch);
private:
    JetAlgorithm::value usedAlgorithm;
    float electromagneticFraction;
    int numberOfRecHitsContaining90PercentOfTheJetEnergy;
    float fractionOfEnergyIntheHottestHPDReadout;
    std::vector<float> btag_discriminators;
    //  float btagInData;
    int numberOfDaughters;
    float chargedEmEnergyFraction, neutralHadronEnergyFraction, neutralEmEnergyFraction;
    float chargedHadronEnergyFraction, chargedMultiplicity;
    int partonFlavour;
};

typedef boost::shared_ptr<Jet> JetPointer;
typedef std::vector<JetPointer> JetCollection;
}

#endif /* JET_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/RecoObjects/Vertex.h
//***********************************************************************


/*
 * PrimaryVertex.h
 *
 *  Created on: 25 Jul 2010
 *      Author: kreczko
 */

#ifndef PRIMARYVERTEX_H_
#define PRIMARYVERTEX_H_
#include <boost/shared_ptr.hpp>
#include <vector>

namespace BAT {

class Vertex {
public:

  Vertex();
  virtual ~Vertex();
  bool isGood() const;
  bool isFake() const;
  unsigned int ndof() const;
  float absoluteZPosition() const;
  float absoluteRho() const;
  float z() const;
  void setFake(bool fake);
  void setDegreesOfFreedom(unsigned int ndof);
  void setZPosition(float z);
  void setRho(float rho);
private:
  bool is_fake;
  unsigned int degreesOfFreedom;
  float z_position;
  float rho;

};
typedef boost::shared_ptr<Vertex> VertexPointer;
typedef std::vector<VertexPointer> VertexCollection;

}

#endif /* PRIMARYVERTEX_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/RecoObjects/PseudoParticle.h
//***********************************************************************


/*
 * PseudoParticle.h
 *
 *  Created on: 28 Sep 2010
 *      Author: kreczko
 */

#ifndef PSEUDOPARTICLE_H_
#define PSEUDOPARTICLE_H_
#include "Particle.h"

namespace BAT {
class PseudoParticle;

typedef boost::shared_ptr<PseudoParticle> PseudoParticlePointer;
typedef std::vector<PseudoParticle> PseudoParticleCollection;

class PseudoParticle {
protected:
    float Phi, Eta, Pt, Theta, D0, Charge;
public:
    PseudoParticle();
    PseudoParticle(float phi, float eta, float pt, float theta);
    virtual ~PseudoParticle();
    float pt() const;
    float eta() const;
    float phi() const;
    float theta() const;
    float charge() const;
    float d0() const;

    void setPt(float pt);
    void setEta(float eta);
    void setPhi(float phi);
    void setTheta(float theta);
    void setCharge(float charge);
    void setD0(float d0);

    float deltaR(float phi1, float eta1, float phi2, float eta2) const;
    float deltaR(const ParticlePointer otherParticle) const;
    float deltaR(const PseudoParticlePointer otherParticle) const;
    float deltaPhi(float phi1, float phi2) const;
    float deltaEta(float eta1, float eta2) const;
    bool isWithinDeltaR(float delta_R, const ParticlePointer particle) const;
    bool isWithinDeltaR(float delta_R, const PseudoParticlePointer particle) const;
};

}

#endif /* PSEUDOPARTICLE_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/EventCounter.h
//***********************************************************************


/*
 * EventCounter.h
 *
 *  Created on: 4 Jul 2010
 *      Author: kreczko
 */

#ifndef EVENTCOUNTER_H_
#define EVENTCOUNTER_H_
#include "boost/multi_array.hpp"

namespace BAT {
typedef boost::multi_array<unsigned long, 3> integerCounter;
typedef integerCounter::size_type size_type_int;

typedef boost::multi_array<double, 3> floatCounter;
typedef floatCounter::size_type size_type_float;

struct Counter {
private:
    unsigned int dim1, dim2, dim3;
    integerCounter unweightedEntries;
    floatCounter weightedEntries;
    unsigned int eventType;

public:
    Counter() {
    }

    Counter(unsigned int dimension1, unsigned int dimension2, unsigned int dimension3) :
        dim1(dimension1),
        dim2(dimension2),
        dim3(dimension3),
        unweightedEntries(boost::extents[dimension1][dimension2][dimension3]),
        weightedEntries(boost::extents[dimension1][dimension2][dimension3]) {
    }

    ~Counter() {
    }

    void increase(const unsigned int dimension1, const unsigned int dimension2, const unsigned int dimension3,
            const double weight = 1.0) {
        unweightedEntries[dimension1][dimension2][dimension3]++;
        weightedEntries[dimension1][dimension2][dimension3] += weight;
    }

    unsigned int getEntries(unsigned int dimension1, unsigned int dimension2, unsigned int dimension3) const{
        return unweightedEntries[dimension1][dimension2][dimension3];
    }

    float getWeightedEntries(unsigned int dimension1, unsigned int dimension2, unsigned int dimension3) const{
        return weightedEntries[dimension1][dimension2][dimension3];
    }

    unsigned int sumThirdDimension(unsigned int dimension1, unsigned int dimension2) const{
        unsigned int sum = 0;
        for(unsigned int third = 0; third < dim3; ++third){
            sum += weightedEntries[dimension1][dimension2][third];
        }
        return sum;
    }

    unsigned int sumThirdDimensionUnweighted(unsigned int dimension1, unsigned int dimension2) const{
            unsigned int sum = 0;
            for(unsigned int third = 0; third < dim3; ++third){
                sum += unweightedEntries[dimension1][dimension2][third];
            }
            return sum;
        }

    unsigned int getSizeOfFirstDimension() const{
        return unweightedEntries.size();
    }

    unsigned int getSizeOfSecondDimension() const{
        return unweightedEntries.shape()[1];
    }

    unsigned int getSizeOfThirdDimension() const{
        return unweightedEntries.shape()[2];
    }

    //TODO: subcount

};
}
#endif /* EVENTCOUNTER_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/Readers/VertexReader.h
//***********************************************************************


/*
 * PrimaryVertexReader.h
 *
 *  Created on: 25 Jul 2010
 *      Author: kreczko
 */

#ifndef PRIMARYVERTEXREADER_H_
#define PRIMARYVERTEXREADER_H_
#include "VariableReader.h"
#include "../RecoObjects/Vertex.h"
namespace BAT {

class VertexReader {
public:
  VertexReader();
  VertexReader(TChainPointer input);
  virtual ~VertexReader();
  const VertexCollection& getVertices();
  void initialise();
private:
  VariableReader<MultiDoublePointer> ndofReader;
  VariableReader<MultiDoublePointer> zReader;
  VariableReader<MultiDoublePointer> rhoReader;
  VariableReader<MultiBoolPointer> isfakeReader;

  VertexCollection vertices;

  void readVertices();
};

}

#endif /* PRIMARYVERTEXREADER_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/Readers/METReader.h
//***********************************************************************


/*
 * METReader.h
 *
 *  Created on: 4 Aug 2010
 *      Author: kreczko
 */

#ifndef METREADER_H_
#define METREADER_H_
#include "VariableReader.h"
#include "../RecoObjects/MET.h"

namespace BAT {

class METReader {
public:
//    const static std::string algorithmPrefixes[METAlgorithm::NUMBER_OF_METALGORITHMS];

    METReader();
    METReader(TChainPointer input, METAlgorithm::value algo = METAlgorithm::Calo);
    const METPointer getMET();
    virtual ~METReader();
    void initialise();
private:
    VariableReader<MultiDoublePointer> exReader;
    VariableReader<MultiDoublePointer> eyReader;
    METPointer met;
    METAlgorithm::value usedAlgorithm;
    void readMET();
};

}

#endif /* METREADER_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/Readers/ElectronReader.h
//***********************************************************************


/*
 * ElectronReader.h
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#ifndef ELECTRONREADER_H_
#define ELECTRONREADER_H_
#include "VariableReader.h"
#include "../RecoObjects/Electron.h"

namespace BAT {
class ElectronReader {
public:
  ElectronReader();
  ElectronReader(TChainPointer input, ElectronAlgorithm::value algo = ElectronAlgorithm::Calo);
  virtual ~ElectronReader();
  const ElectronCollection& getElectrons();
  void initialise();
private:
  VariableReader<MultiDoublePointer> energyReader;
  VariableReader<MultiDoublePointer> pxReader;
  VariableReader<MultiDoublePointer> pyReader;
  VariableReader<MultiDoublePointer> pzReader;
  VariableReader<MultiIntPointer> chargeReader;
  VariableReader<MultiDoublePointer> superClusterEtaReader;
  VariableReader<MultiDoublePointer> d0_BS_Reader;
  VariableReader<MultiDoublePointer> d0_PV_Reader;
  VariableReader<MultiIntPointer> numberOfInnerLayerMissingHitsReader;

  VariableReader<MultiDoublePointer> ecalIsolationReader;
  VariableReader<MultiDoublePointer> hcalIsolationReader;
  VariableReader<MultiDoublePointer> trackerIsolationReader;

  VariableReader<MultiDoublePointer> PFGammaIsolationReader;
    VariableReader<MultiDoublePointer> PFChargedHadronIsolationReader;
    VariableReader<MultiDoublePointer> PFNeutralHadronIsolationReader;

  VariableReader<MultiDoublePointer> sigmaIEtaIEtaReader;
  VariableReader<MultiDoublePointer> dPhiInReader;
  VariableReader<MultiDoublePointer> dEtaInReader;
  VariableReader<MultiDoublePointer> hadOverEmReader;

  VariableReader<MultiDoublePointer> sharedFractionInnerHits;
  VariableReader<MultiIntPointer> trackIDReader;
  VariableReader<MultiDoublePointer> track_phi;
  VariableReader<MultiDoublePointer> track_eta;
  VariableReader<MultiDoublePointer> track_pt;
  VariableReader<MultiDoublePointer> track_theta;
  VariableReader<MultiIntPointer> track_charge;

  VariableReader<MultiDoublePointer> vertex_dist_z;
  VariableReader<MultiDoublePointer> dist;
  VariableReader<MultiDoublePointer> dCotTheta;
  ElectronAlgorithm::value algorithm;
  ElectronCollection electrons;
  void readElectrons();

};

}

#endif /* ELECTRONREADER_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/Readers/GenJetReader.h
//***********************************************************************


/*
 * GenJetReader.h
 *
 *  Created on: 14 Mar 2011
 *      Author: kreczko
 */

#ifndef GENJETREADER_H_
#define GENJETREADER_H_
#include "VariableReader.h"
#include "../RecoObjects/Jet.h"

namespace BAT {

class GenJetReader {
public:
  GenJetReader();
  GenJetReader(TChainPointer);
  virtual ~GenJetReader();
  virtual const JetCollection& getGenJets();
  virtual void initialise();

protected:
  VariableReader<MultiDoublePointer> genEnergyReader;
  VariableReader<MultiDoublePointer> genPxReader;
  VariableReader<MultiDoublePointer> genPyReader;
  VariableReader<MultiDoublePointer> genPzReader;
  VariableReader<MultiDoublePointer> genMassReader;
  VariableReader<MultiDoublePointer> genChargeReader;
  VariableReader<MultiDoublePointer> genEmfReader;

  JetCollection genJets;
  virtual void readGenJets();

};

}

#endif /* GENJETREADER_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/Readers/NTupleEventReader.h
//***********************************************************************


/*
 * NTupleEventReader.h
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#ifndef NTUPLEEVENTREADER_H_
#define NTUPLEEVENTREADER_H_
#include <boost/scoped_ptr.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/array.hpp>
#include "TChain.h"
#include "../Event.h"
#include "ElectronReader.h"
#include "JetReader.h"
#include "GenJetReader.h"
#include "MuonReader.h"
#include "VariableReader.h"
#include "VertexReader.h"
#include "METReader.h"
#include "TrackReader.h"
#include "GenParticleReader.h"
#include <string>
#include "../CrossSections.h"

namespace BAT {
struct NoFileFoundException: public std::exception {
    TString msg;
    NoFileFoundException(TString message) :
        msg(message) {
    }
    ~NoFileFoundException() throw () {
    }

    const char* what() const throw () {
        return msg;
    }
};

class NTupleEventReader {
public:
  static const char * EVENT_CHAIN;

  static JetAlgorithm::value jetAlgorithm;
  static ElectronAlgorithm::value electronAlgorithm;
  static METAlgorithm::value metAlgorithm;
  static MuonAlgorithm::value muonAlgorithm;
  static bool loadTracks;

  NTupleEventReader();
  virtual ~NTupleEventReader();
  const Event& getNextEvent();
  bool hasNextEvent();
  void addInputFile(const char* fileName);
  // without check for unit tests -> faster to start, no difference in long analysis
  void addInputFileWithoutCheck(const char* fileName);
  void addInputFile(const char* fileName, DataType::value type);
  void skipNumberOfEvents(unsigned long skipNextNEvents);
  unsigned long getNumberOfProccessedEvents() const;
  unsigned long getCurrentLocalEventNumber() const;
  void setMaximumNumberOfEvents(unsigned long maxNumberOfEvents);
  const boost::array<bool, DataType::NUMBER_OF_DATA_TYPES>& getSeenDatatypes();
  const char* getCurrentFile() const;
  Double_t test;
private:
  unsigned long processedEvents;
  unsigned long maximalNumberOfEvents;
  unsigned long currentEventEntry;
  unsigned long numberOfFiles;
  boost::shared_ptr<TChain> input;
  boost::shared_ptr<VariableReader<MultiIntPointer> > hltReader;
  boost::scoped_ptr<VertexReader> vertexReader;
  boost::scoped_ptr<TrackReader> trackReader;
  boost::scoped_ptr<ElectronReader> electronReader;
  boost::scoped_ptr<GenParticleReader> genParticleReader;
  boost::scoped_ptr<JetReader> jetReader;
  boost::scoped_ptr<GenJetReader> genJetReader;
  boost::scoped_ptr<MuonReader> muonReader;
  boost::scoped_ptr<METReader> metReader;

  boost::scoped_ptr<VariableReader<unsigned int> > runNumberReader;
  boost::scoped_ptr<VariableReader<unsigned int> > eventNumberReader;
  boost::scoped_ptr<VariableReader<unsigned int> > lumiBlockReader;
//  boost::scoped_ptr<VariableReader<bool> > beamScrapingReader;
  bool areReadersSet, areDatatypesKnown;
  Event currentEvent;
  boost::array<bool, DataType::NUMBER_OF_DATA_TYPES> seenDataTypes;

  void selectNextNtupleEvent();
  void initiateReadersIfNotSet();
  DataType::value getDataType(const std::string filename);
  void readDataTypes();
};
}

#endif /* NTUPLEEVENTREADER_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/Readers/GenParticleReader.h
//***********************************************************************


/*
 * GenParticleReader.h
 *
 *  Created on: Feb 23, 2011
 *      Author: phzss
 */

#ifndef GENPARTICLEREADER_H_
#define GENPARTICLEREADER_H_
#include "../RecoObjects/MCParticle.h"
#include "VariableReader.h"

namespace BAT {

class GenParticleReader {
private:
    VariableReader<MultiDoublePointer> energyReader;
    VariableReader<MultiDoublePointer> pxReader;
    VariableReader<MultiDoublePointer> pyReader;
    VariableReader<MultiDoublePointer> pzReader;

    VariableReader<MultiIntPointer> pdgIdReader;
    VariableReader<MultiIntPointer> statusReader;
    VariableReader<MultiIntPointer> motherIndexReader;

    MCParticleCollection genParticles;
    void readGenParticles();
public:
    GenParticleReader();
    GenParticleReader(TChainPointer input);
    virtual ~GenParticleReader();
    const MCParticleCollection& getGenParticles();
    void initialise();
};

}

#endif /* GENPARTICLEREADER_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/Readers/VariableReader.h
//***********************************************************************


/*
 * VariableReader.h
 *
 *  Created on: Jun 24, 2010
 *      Author: lkreczko
 */

#ifndef READER_H_
#define READER_H_
#include <boost/shared_ptr.hpp>
#include "TChain.h"
#include "TBranch.h"
#include "TString.h"
#include <exception>

typedef std::vector<float>* MultiFloatPointer;
typedef std::vector<double>* MultiDoublePointer;
typedef std::vector<int>* MultiIntPointer;
typedef std::vector<bool>* MultiBoolPointer;
typedef std::vector<unsigned int>* MultiUIntPointer;

typedef boost::shared_ptr<TChain> TChainPointer;
namespace BAT {
struct VariableNotFoundException: public std::exception {
    TString msg;
    VariableNotFoundException(TString message) :
        msg(message) {
    }
    ~VariableNotFoundException() throw () {
    }

    const char* what() const throw () {
        return msg;
    }
};

struct VariableNotInitialisedException: public std::exception {
    TString msg;
    VariableNotInitialisedException(TString message) :
        msg(message) {
    }
    ~VariableNotInitialisedException() throw () {
    }

    const char* what() const throw () {
        return msg;
    }
};

template<typename variableType = unsigned int>
class VariableReader {
public:
    VariableReader() :
        input(), variable(0), variableName("") {

    }

    VariableReader(TChainPointer chain, TString varName) :
        input(chain), variable(0), variableName(varName) {

    }

    ~VariableReader() {
    }

    const variableType& getVariable() {
        return variable;
    }

    double getVariableAt(unsigned int index) const;
    int getIntVariableAt(unsigned int index) const;
    unsigned int getUIntVariableAt(unsigned int index) const;
    bool getBoolVariableAt(unsigned int index) const;
    unsigned int size() const;

    void initialise() {
        if (doesVariableExist()) {
            enableVariable();
            readVariableFromInput();
        } else
            throw VariableNotFoundException("Variable '" + variableName + "' was not found.");
    }

    void initialiseBlindly() {
        enableVariable();
        readVariableFromInput();
    }

    bool doesVariableExist() {
        return input->GetBranch(variableName) != NULL;
    }

    void throwExceptionIfNotItitialised() const{
        if (variable == 0)
            throw VariableNotFoundException("Trying to access variable '" + variableName + "' before initialisation.");
    }
protected:
    TChainPointer input;
    variableType variable;
    TString variableName;

    void readVariableFromInput() {
        input->SetBranchAddress(variableName, &variable);
    }

    void enableVariable() {
        input->SetBranchStatus(variableName, true);
    }
};

}

#endif /* READER_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/Readers/JetReader.h
//***********************************************************************


/*
 * JetReader.h
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#ifndef JETREADER_H_
#define JETREADER_H_
#include "VariableReader.h"
#include "../RecoObjects/Jet.h"

namespace BAT {

class JetReader {
public:
  JetReader();
  JetReader(TChainPointer,
      JetAlgorithm::value algo = JetAlgorithm::Calo_AntiKT_Cone05);
  virtual ~JetReader();
  virtual const JetCollection& getJets();
//  virtual const JetCollection& getGenJets();
  virtual void initialise();

protected:
  VariableReader<MultiDoublePointer> energyReader;
  VariableReader<MultiDoublePointer> pxReader;
  VariableReader<MultiDoublePointer> pyReader;
  VariableReader<MultiDoublePointer> pzReader;
  VariableReader<MultiDoublePointer> massReader;
  VariableReader<MultiDoublePointer> chargeReader;

  VariableReader<MultiDoublePointer> emfReader;
  VariableReader<unsigned int> numberOfJetsReader;
  VariableReader<MultiIntPointer> n90HitsReader;
  VariableReader<MultiDoublePointer> fHPDReader;

  VariableReader<MultiIntPointer> NODReader;
  VariableReader<MultiDoublePointer> CEFReader;
  VariableReader<MultiDoublePointer> NHFReader;
  VariableReader<MultiDoublePointer> NEFReader;
  VariableReader<MultiDoublePointer> CHFReader;
  VariableReader<MultiIntPointer> NCHReader;

  VariableReader<MultiDoublePointer> btagSimpleSecondaryVertexReader;
  VariableReader<MultiDoublePointer> btagTrackCountingHighPurityReader;
  VariableReader<MultiDoublePointer> btagTrackCountingHighEfficiencyReader;

//  VariableReader<MultiDoublePointer> genEnergyReader;
//  VariableReader<MultiDoublePointer> genPxReader;
//  VariableReader<MultiDoublePointer> genPyReader;
//  VariableReader<MultiDoublePointer> genPzReader;
//  VariableReader<MultiDoublePointer> genMassReader;
//  VariableReader<MultiDoublePointer> genChargeReader;
//  VariableReader<MultiDoublePointer> genEmfReader;

  JetCollection jets;
//  JetCollection genJets;
  JetAlgorithm::value usedAlgorithm;
  virtual void readJets();
//  virtual void readGenJets();

};

}

#endif /* JETREADER_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/Readers/TrackReader.h
//***********************************************************************


/*
 * TrackReader.h
 *
 *  Created on: 20 Sep 2010
 *      Author: kreczko
 */

#ifndef TRACKREADER_H_
#define TRACKREADER_H_
#include "../RecoObjects/Track.h"
#include "VariableReader.h"

namespace BAT {

class TrackReader {
private:
    VariableReader<MultiDoublePointer> phiReader;
    VariableReader<MultiDoublePointer> etaReader;
    VariableReader<MultiDoublePointer> ptReader;
    VariableReader<MultiDoublePointer> thetaReader;
    VariableReader<MultiIntPointer> chargeReader;
    VariableReader<MultiDoublePointer> d0Reader;
    VariableReader<MultiBoolPointer> highPurityReader;

    TrackCollection tracks;
    void readTracks();
public:
    TrackReader();
    TrackReader(TChainPointer input);
    virtual ~TrackReader();
    const TrackCollection& getTracks();
    void initialise();
};

}

#endif /* TRACKREADER_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/Readers/MuonReader.h
//***********************************************************************


/*
 * MuonReader.h
 *
 *  Created on: Jun 25, 2010
 *      Author: lkreczko
 */

#ifndef MUONREADER_H_
#define MUONREADER_H_
#include "VariableReader.h"
#include "../RecoObjects/Muon.h"

namespace BAT {

class MuonReader {
public:
  MuonReader();
  MuonReader(TChainPointer input, MuonAlgorithm::value algo = MuonAlgorithm::Default);
  virtual ~MuonReader();
  const MuonCollection& getMuons();
  void initialise();

private:
//  VariableReader<unsigned int> numberOfMuonsReader;
  VariableReader<MultiDoublePointer> energyReader;
  VariableReader<MultiDoublePointer> pxReader;
  VariableReader<MultiDoublePointer> pyReader;
  VariableReader<MultiDoublePointer> pzReader;

  VariableReader<MultiDoublePointer> ecalIsolationReader;
  VariableReader<MultiDoublePointer> hcalIsolationReader;
  VariableReader<MultiDoublePointer> trackerIsolationReader;

  VariableReader<MultiBoolPointer> isGlobalReader;

  MuonCollection muons;
  void readMuons();
};

}

#endif /* MUONREADER_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/Taggers/ConversionTagger.h
//***********************************************************************


/*
 * ConversionTagger.h
 *
 *  Created on: Jun 30, 2010
 *      Author: lkreczko
 */

#ifndef CONVERSIONTAGGER_H_
#define CONVERSIONTAGGER_H_
#include "../RecoObjects/Electron.h"
#include "../RecoObjects/Track.h"
#include <boost/shared_ptr.hpp>

namespace BAT {

class ConversionTagger {
public:
    ElectronPointer electron;
    TrackCollection tracks;
    TrackPointer partnerTrack;
    TrackPointer electronTrack;
    double minFracSharedHits;
    double distance, deltaCot;
    int electronTrackID;
private:
    void findClosestTrack();
public:
    ConversionTagger();
    virtual ~ConversionTagger();
    void calculateConversionVariables(const ElectronPointer electron, const TrackCollection tracks,
            const double bfieldAtOrigin, double minFracSharedHits);
    const TrackPointer getElectronTrack();
    bool isFromConversion(double maxAbsDistance, double maxAbsDeltaCot);
};

typedef boost::shared_ptr<ConversionTagger> ConversionTaggerPointer;

}

#endif /* CONVERSIONTAGGER_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/ToplikeCandidate.h
//***********************************************************************


#ifndef TOPLIKECANDIDATE_H_
#define TOPLIKECANDIDATE_H_


#include "RecoObjects/MCParticle.h"
#include "TopPairEventCandidate.h"

using namespace BAT;

namespace BAT {

typedef struct {
  float deltaR;
  bool leptonic, hadronic;
} topTruth;

typedef struct {
  float deltaR;
  int gpInd;
  MCParticlePointer ptr;
} mcObj;


typedef std::vector< mcObj > mcList;


class ToplikeCandidate : public TopPairEventCandidate {

protected:
    // ElectronPointer electronFromW;
    // JetPointer leptonicBJet, hadronicBJet, jet1FromW, jet2FromW;
    JetPointer jet3FromW, jet4FromW;
    ParticlePointer hadronicWtPrime, tPrime;
    // ParticlePointer neutrino1, neutrino2, leptonicW1, leptonicW2, hadronicW,
    // leptonicTop1, leptonicTop2, hadronicTop, ttbarResonance;
    // unsigned short selectedNeutrino, currentSelectedNeutrino, hadronicBIndex,
    // leptonicBIndex, jet1FromWIndex, jet2FromWIndex;
    unsigned short jet3FromWIndex, jet4FromWIndex;
    double ptTprimeSystem, htSystem;
    bool doneReconstructiontop;
    mcList getMCList(const Particle *const recoObject) const;
    int chkMCMatch(const Particle *const recoObject, int motherInd, 
      const int pdgId, int antiId = 0) const;
    int chkForQuark(const JetPointer recoObject, const int motherInd,
      const int badInd = -1) const;
    int getNumMCMatchesForTop(const ParticlePointer &recoTop, 
      bool hadronic = true) const;
    int strictHTopMatching(const mcObj &topTru) const;
    int strictLTopMatching(const mcObj &topTru) const;
    
public:
    ToplikeCandidate();
    ToplikeCandidate(const Event& event);
    virtual ~ToplikeCandidate();

    /*
    const JetPointer getJet3FromHadronicW2() const;
    const JetPointer getJet4FromHadronicW2() const;
    const ParticlePointer getHadronicW2() const;
    const ParticlePointer getTprimeResonance() const;
    */

    void recoTprimeUsingChi2(ElectronPointer electron);
    void recoBestSingleTop(ElectronPointer electron);
    double TPrimeHTSystem() const;
    double PtTPrimeSystem() const;

    // Overload the following
    const ParticlePointer getResonance() const;
    double tpmass() const;
    double getGlobalChi2() const;
    // double getTotalChi2() const;
    double getWChi2() const;
    double sumPt() const;
    double PtTtbarSystem() const;
    double PtTtbarSystem(unsigned short neutrinoSolution) const;
    double getHadronicChi2() const;
    virtual double getLoneHadChi2() const;
    topTruth getMCMatches(const ParticlePointer &recoObject) const;
    int getNumMCMatchesHTop() const;
    int getNumMCMatchesLTop() const;
    int getNumCorrectIDLTop() const;
    int getNumCorrectIDHTop() const;
};


class TopNoMassConstraint : public ToplikeCandidate {
public:
  TopNoMassConstraint();
  TopNoMassConstraint(const Event& event);
  virtual ~TopNoMassConstraint();
  
  double getLeptonicChi2(double unused, double angle) const;
  double getLoneHadChi2() const;
};

}

#endif /* TOPLIKECANDIDATE_H_ */


//***********************************************************************
//***** src/OSUAnalysis/Tools/interface/ReconstructionRules/BasicRule.h
//***********************************************************************


/*
 * BasicRule.h
 *
 *  Created on: 15 Apr 2011
 *      Author: kreczko
 */

#ifndef BASICRULE_H_
#define BASICRULE_H_

#include "../RecoObjects/Jet.h"
#include "../TtbarHypothesis.h"
namespace BAT {

class BasicRule {
public:
    BasicRule();
    virtual ~BasicRule();

    double softLeptonicBJetCondition(const JetPointer jet) const;
    bool hardLeptonicBJetCondition(const JetPointer jet) const;

    double softHadronicBJetCondition(const JetPointer jet) const;
    bool hardHadronicBJetCondition(const JetPointer jet) const;

    double softHadronicJetFromWCondition(const JetPointer jet) const;
    bool hardHadronicJetFromWCondition(const JetPointer jet) const;

    double softGlobalCondition(const TtbarHypothesisPointer hypothesis) const;
    bool hardGlobalCondition(const TtbarHypothesisPointer hypothesis) const;

    bool meetsInitialConditaion() const;
};

typedef boost::shared_ptr<BasicRule> Rule;
}

#endif /* BASICRULE_H_ */
